# Internet Relay Chat Protocol

Network Working Group                                      J. Oikarinen
Request for Comments: 1459                                D. Reed
                                                         1993년 5월

## 본 문서의 상태

본 메모는 인터넷 커뮤니티를 위한 실험적 프로토콜을 정의합니다. 개선을 위한 토론과 제안을 환영합니다. 이 프로토콜의 표준화 상태와 현황에 대해서는 현재 "IAB Official Protocol Standards" 판을 참조하시기 바랍니다. 본 메모의 배포에는 제한이 없습니다.

## 초록

IRC 프로토콜은 BBS 사용자들이 서로 대화할 수 있는 수단으로 처음 구현된 이후 지난 4년간 개발되어 왔습니다. 현재는 전 세계적인 서버와 클라이언트 네트워크를 지원하고 있으며, 성장에 대응하기 위해 노력하고 있습니다. 지난 2년 동안 주요 IRC 네트워크에 접속한 평균 사용자 수는 10배 증가했습니다.

IRC 프로토콜은 텍스트 기반 프로토콜이며, 가장 단순한 클라이언트는 서버에 연결할 수 있는 모든 소켓 프로그램이 될 수 있습니다.

## 목차

1. 소개 ....................................................... 4  
   1.1 서버 ................................................... 4  
   1.2 클라이언트 ............................................. 5  
      1.2.1 운영자 ............................................ 5  
   1.3 채널 ................................................... 5  
      1.3.1 채널 운영자 ....................................... 6  
2. IRC 명세 ................................................... 7  
   2.1 개요 ................................................... 7  
   2.2 문자 코드 .............................................. 7  
   2.3 메시지 ................................................. 7  
      2.3.1 'pseudo' BNF의 메시지 형식 ......................... 8  
   2.4 숫자 응답 .............................................. 10  
3. IRC 개념 ................................................... 10  
   3.1 일대일 통신 ............................................ 10  
   3.2 일대다 ................................................. 11  
      3.2.1 목록으로 ........................................... 11  
      3.2.2 그룹으로 (채널) .................................... 11  
      3.2.3 호스트/서버 마스크로 ............................... 12  
   3.3 일대전체 ............................................... 12  
      3.3.1 클라이언트 대 클라이언트 ........................... 12  
      3.3.2 클라이언트 대 서버 ................................. 12  
      3.3.3 서버 대 서버 ....................................... 12  
4. 메시지 상세 ................................................ 13  
   4.1 연결 등록 .............................................. 13  
      4.1.1 Password 메시지 .................................... 14  
      4.1.2 Nickname 메시지 .................................... 14  
      4.1.3 User 메시지 ........................................ 15  
      4.1.4 Server 메시지 ...................................... 16  
      4.1.5 Operator 메시지 .................................... 17  
      4.1.6 Quit 메시지 ........................................ 17  
      4.1.7 Server Quit 메시지 ................................. 18  
   4.2 채널 운영 .............................................. 19  
      4.2.1 Join 메시지 ........................................ 19  
      4.2.2 Part 메시지 ........................................ 20  
      4.2.3 Mode 메시지 ........................................ 21  
         4.2.3.1 채널 모드 ..................................... 21  
         4.2.3.2 사용자 모드 ................................... 22  
      4.2.4 Topic 메시지 ....................................... 23  
      4.2.5 Names 메시지 ....................................... 24  
      4.2.6 List 메시지 ........................................ 24  
      4.2.7 Invite 메시지 ...................................... 25  
      4.2.8 Kick 메시지 ........................................ 25  
   4.3 서버 쿼리와 명령 ....................................... 26  
      4.3.1 Version 메시지 ..................................... 26  
      4.3.2 Stats 메시지 ....................................... 27  
      4.3.3 Links 메시지 ....................................... 28  
      4.3.4 Time 메시지 ........................................ 29  
      4.3.5 Connect 메시지 ..................................... 29  
      4.3.6 Trace 메시지 ....................................... 30  
      4.3.7 Admin 메시지 ....................................... 31  
      4.3.8 Info 메시지 ........................................ 31  
   4.4 메시지 전송 ............................................ 32  
      4.4.1 Private 메시지 ..................................... 32  
      4.4.2 Notice 메시지 ...................................... 33  
   4.5 사용자 기반 쿼리 ....................................... 33  
      4.5.1 Who 쿼리 ........................................... 33  
      4.5.2 Whois 쿼리 ......................................... 34  
      4.5.3 Whowas 메시지 ...................................... 35  
   4.6 기타 메시지 ............................................ 35  
      4.6.1 Kill 메시지 ........................................ 36  
      4.6.2 Ping 메시지 ........................................ 37  
      4.6.3 Pong 메시지 ........................................ 37  
      4.6.4 Error 메시지 ....................................... 38  
5. 선택적 메시지 .............................................. 38  
   5.1 Away 메시지 ............................................ 38  
   5.2 Rehash 명령 ............................................ 39  
   5.3 Restart 명령 ........................................... 39  
   5.4 Summon 메시지 .......................................... 40  
   5.5 Users 메시지 ........................................... 40  
   5.6 Operwall 명령 .......................................... 41  
   5.7 Userhost 메시지 ........................................ 42  
   5.8 Ison 메시지 ............................................ 42  
6. 응답 ...................................................... 43  
   6.1 오류 응답 .............................................. 43  
   6.2 명령 응답 .............................................. 48  
   6.3 예약된 숫자 ............................................ 56  
7. 클라이언트와 서버 인증 ..................................... 56  
8. 현재 구현 세부사항 ......................................... 56  
   8.1 네트워크 프로토콜: TCP ................................. 57  
      8.1.1 Unix 소켓 지원 .................................... 57  
   8.2 명령 파싱 .............................................. 57  
   8.3 메시지 전달 ............................................ 57  
   8.4 연결 '활성도' .......................................... 58  
   8.5 서버-클라이언트 연결 설정 .............................. 58  
   8.6 서버-서버 연결 설정 .................................... 58  
      8.6.1 연결 시 상태 정보 교환 ............................ 59  
   8.7 서버-클라이언트 연결 종료 .............................. 59  
   8.8 서버-서버 연결 종료 .................................... 59  
   8.9 닉네임 변경 추적 ....................................... 60  
   8.10 클라이언트 플러드 제어 ................................ 60  
   8.11 논블로킹 룩업 ......................................... 61  
      8.11.1 호스트네임(DNS) 룩업 ............................. 61  
      8.11.2 사용자이름(Ident) 룩업 ........................... 61  
   8.12 설정 파일 ............................................. 61  
      8.12.1 클라이언트 연결 허용 ............................. 62  
      8.12.2 운영자 ........................................... 62  
      8.12.3 서버 연결 허용 ................................... 62  
      8.12.4 관리 ............................................. 63  
   8.13 채널 멤버십 ........................................... 63  
9. 현재 문제점 ............................................... 63  
   9.1 확장성 ................................................ 63  
   9.2 레이블 ................................................ 63  
      9.2.1 닉네임 ............................................ 63  
      9.2.2 채널 .............................................. 64  
      9.2.3 서버 .............................................. 64  
   9.3 알고리즘 .............................................. 64  
10. 지원 및 가용성 ........................................... 64  
11. 보안 고려사항 ............................................ 65  
12. 저자 주소 ................................................ 65  

## 1. 소개

IRC(Internet Relay Chat) 프로토콜은 텍스트 기반 컨퍼런싱을 위해 수년에 걸쳐 설계되었습니다. 이 문서는 현재의 IRC 프로토콜을 설명합니다.

IRC 프로토콜은 TCP/IP 네트워크 프로토콜을 사용하는 시스템에서 개발되었지만, 이것이 유일한 운영 영역으로 남아야 한다는 요구사항은 없습니다.

IRC 자체는 텔레컨퍼런싱 시스템으로, (클라이언트-서버 모델을 통해) 분산된 방식으로 많은 기기에서 실행하기에 매우 적합합니다. 일반적인 설정에는 클라이언트가 연결하여 서로 대화할 수 있는 중심점을 형성하고, 필요한 메시지 전달/멀티플렉싱 및 기타 기능을 수행하는 단일 프로세스(서버)가 포함됩니다.

### 1.1 서버

서버는 IRC의 중추를 형성하여 클라이언트가 서로 대화하기 위해 연결할 수 있는 지점과 다른 서버가 연결하여 IRC 네트워크를 형성할 수 있는 지점을 제공합니다. IRC 서버에 허용되는 유일한 네트워크 구성은 신장 트리 형태입니다[그림 1 참조]. 여기서 각 서버는 자신이 보는 나머지 네트워크에 대한 중앙 노드 역할을 합니다.

                           [ Server 15 ]  [ Server 13 ] [ Server 14]
                                 /                \         /
                                /                  \       /
        [ Server 11 ] ------ [ Server 1 ]       [ Server 12]
                              /        \          /
                             /          \        /
                  [ Server 2 ]          [ Server 3 ]
                    /       \                      \
                   /         \                      \
           [ Server 4 ]    [ Server 5 ]         [ Server 6 ]
            /    |    \                           /
           /     |     \                         /
          /      |      \____                   /
         /       |           \                 /
 [ Server 7 ] [ Server 8 ] [ Server 9 ]   [ Server 10 ]

                                  :
                               [ etc. ]
                                  :

                 [ 그림 1. IRC 서버 네트워크의 형식 ]

### 1.2 클라이언트

클라이언트는 다른 서버가 아닌 서버에 연결하는 모든 것을 의미합니다. 각 클라이언트는 최대 9자 길이의 고유한 닉네임으로 다른 클라이언트와 구별됩니다. 닉네임에 사용할 수 있는 것과 없는 것에 대해서는 프로토콜 문법 규칙을 참조하십시오. 닉네임 외에도 모든 서버는 모든 클라이언트에 대해 다음 정보를 가지고 있어야 합니다: 클라이언트가 실행되는 호스트의 실제 이름, 해당 호스트에서의 클라이언트의 사용자 이름, 그리고 클라이언트가 연결된 서버.

#### 1.2.1 운영자

IRC 네트워크 내에서 적절한 질서를 유지하기 위해 특별한 클라이언트 클래스(운영자)가 네트워크의 일반적인 유지보수 기능을 수행할 수 있도록 허용됩니다. 운영자에게 부여된 권한은 '위험'할 수 있지만, 그럼에도 필요합니다. 운영자는 잘못된 네트워크 라우팅의 장기적인 사용을 방지하기 위해 필요에 따라 서버의 연결을 끊고 다시 연결하는 등의 기본적인 네트워크 작업을 수행할 수 있어야 합니다. 이러한 필요성을 인정하여, 여기서 논의되는 프로토콜은 운영자만이 이러한 기능을 수행할 수 있도록 제공합니다. 4.1.7절(SQUIT)과 4.3.5절(CONNECT)을 참조하십시오.

운영자의 더 논란이 되는 권한은 사용자를 '강제로' 연결된 네트워크에서 제거할 수 있는 능력입니다. 즉, 운영자는 모든 클라이언트와 서버 간의 연결을 닫을 수 있습니다. 이에 대한 정당성은 섬세한데, 그 남용이 파괴적이고 성가시기 때문입니다. 이러한 유형의 조치에 대한 자세한 내용은 4.6.1절(KILL)을 참조하십시오.

### 1.3 채널

채널은 하나 이상의 클라이언트로 구성된 명명된 그룹으로, 해당 채널에 전달된 메시지를 모두 수신합니다. 채널은 첫 클라이언트가 참여할 때 암시적으로 생성되며, 마지막 클라이언트가 떠날 때 채널은 소멸됩니다. 채널이 존재하는 동안, 모든 클라이언트는 채널 이름을 사용하여 채널을 참조할 수 있습니다.

채널 이름은 ('&' 또는 '#' 문자로 시작하는) 최대 200자 길이의 문자열입니다. 첫 문자가 '&' 또는 '#'이어야 한다는 요구사항 외에도, 채널 이름에 대한 유일한 제한은 공백(' '), 제어 G(^G 또는 ASCII 7), 또는 쉼표(',', 프로토콜에서 목록 항목 구분자로 사용됨)를 포함할 수 없다는 것입니다.

이 프로토콜에서는 두 가지 유형의 채널이 허용됩니다. 하나는 네트워크에 연결된 모든 서버에 알려진 분산 채널이며, 이러한 채널은 첫 문자가 '#'으로 표시됩니다. 다른 하나는 채널이 존재하는 서버의 클라이언트만 참여할 수 있는 로컬 채널입니다. 이러한 채널은 선행 '&' 문자로 구분됩니다. 이 두 가지 유형 외에도, 개별 채널의 특성을 변경할 수 있는 다양한 채널 모드가 있습니다. 이에 대한 자세한 내용은 4.2.3절(MODE 명령)을 참조하십시오.

새 채널을 만들거나 기존 채널의 일부가 되려면, 사용자는 채널에 JOIN해야 합니다. JOIN 이전에 채널이 존재하지 않는 경우, 채널이 생성되고 생성한 사용자가 채널 운영자가 됩니다. 채널이 이미 존재하는 경우, JOIN 요청이 수락되는지 여부는 채널의 현재 모드에 따라 달라집니다. 예를 들어, 채널이 초대 전용(+i)인 경우 초대를 받은 경우에만 참여할 수 있습니다. 프로토콜의 일부로서, 사용자는 한 번에 여러 채널의 일부가 될 수 있지만, 경험이 많은 사용자와 초보 사용자 모두에게 10개의 채널 제한이 충분한 것으로 권장됩니다. 이에 대한 자세한 내용은 8.13절을 참조하십시오.

두 서버 간의 분할로 인해 IRC 네트워크가 분리되면, 각 측의 채널은 분할의 각 측에 연결된 서버에 연결된 클라이언트로만 구성되며, 한쪽에서는 존재하지 않을 수 있습니다. 분할이 치유되면, 연결되는 서버들은 각각의 채널에 누가 있다고 생각하는지와 해당 채널의 모드를 서로에게 알립니다. 채널이 양쪽에 존재하는 경우, JOIN과 MODE는 포용적인 방식으로 해석되어 새로운 연결의 양쪽이 채널에 있는 클라이언트와 채널이 가진 모드에 대해 동의하게 됩니다.

#### 1.3.1 채널 운영자

주어진 채널의 채널 운영자(또는 "chop" 또는 "chanop"이라고도 함)는 해당 채널을 '소유'하는 것으로 간주됩니다. 이러한 상태를 인정하여, 채널 운영자에게는 채널의 통제와 일종의 질서를 유지할 수 있는 특정한 권한이 부여됩니다. 채널의 소유자로서, 채널 운영자는 자신의 행동에 대한 이유를 제시할 필요는 없지만, 만약 그들의 행동이 일반적으로 반사회적이거나 다른 방식으로 남용적인 경우, IRC 운영자에게 개입을 요청하거나, 사용자들이 떠나서 자신들의 채널을 만드는 것이 합리적일 수 있습니다.

채널 운영자만 사용할 수 있는 명령은 다음과 같습니다:

        KICK    - 채널에서 클라이언트 퇴출
        MODE    - 채널의 모드 변경
        INVITE  - 초대 전용 채널(모드 +i)에 클라이언트 초대
        TOPIC   - 모드 +t 채널에서 채널 주제 변경

채널 운영자는 채널과 연관될 때마다 닉네임 옆에 '@' 기호로 식별됩니다(즉, NAMES, WHO 및 WHOIS 명령에 대한 응답).

### 2. IRC 명세

#### 2.1 개요

여기서 설명하는 프로토콜은 서버 간 연결과 클라이언트-서버 연결 모두에 사용됩니다. 그러나 (신뢰할 수 없는 것으로 간주되는) 클라이언트 연결에는 서버 연결보다 더 많은 제한이 있습니다.

#### 2.2 문자 코드

특정 문자 집합은 지정되지 않습니다. 프로토콜은 8비트로 구성된 코드 집합을 기반으로 하며, 이는 옥텟을 구성합니다. 각 메시지는 이러한 옥텟의 수에 관계없이 구성될 수 있습니다. 그러나 일부 옥텟 값은 메시지 구분자 역할을 하는 제어 코드로 사용됩니다.

8비트 프로토콜임에도 불구하고, 구분자와 키워드는 USASCII 터미널과 텔넷 연결에서도 대부분 사용할 수 있도록 되어 있습니다.

IRC의 스칸디나비아 기원으로 인해, 문자 {}|는 문자 []\의 소문자 등가물로 간주됩니다. 이는 두 닉네임의 동등성을 결정할 때 중요한 문제입니다.

### 2.3 메시지

서버와 클라이언트는 응답을 생성할 수도 있고 하지 않을 수도 있는 메시지를 서로 주고받습니다. 메시지가 이후 섹션에서 설명하는 유효한 명령을 포함하는 경우, 클라이언트는 지정된 대로 응답을 기대해야 하지만 영원히 기다리는 것은 권장되지 않습니다. 클라이언트와 서버 간, 그리고 서버와 서버 간의 통신은 본질적으로 비동기적입니다.

각 IRC 메시지는 최대 세 가지 주요 부분으로 구성될 수 있습니다: 접두사(선택적), 명령, 그리고 명령 매개변수(최대 15개까지 가능). 접두사, 명령, 그리고 모든 매개변수는 하나(또는 그 이상)의 ASCII 공백 문자(0x20)로 구분됩니다.

접두사의 존재는 단일 선행 ASCII 콜론 문자(':', 0x3b)로 표시되며, 이는 메시지 자체의 첫 번째 문자여야 합니다. 콜론과 접두사 사이에는 간격(공백)이 없어야 합니다. 접두사는 서버가 메시지의 실제 출처를 나타내기 위해 사용됩니다. 메시지에 접두사가 없는 경우, 메시지가 수신된 연결에서 발생한 것으로 간주됩니다. 클라이언트는 자신으로부터 메시지를 보낼 때 접두사를 사용해서는 안 됩니다. 접두사를 사용하는 경우, 클라이언트와 연관된 등록된 닉네임만이 유효한 접두사입니다. 접두사로 식별된 소스를 서버의 내부 데이터베이스에서 찾을 수 없거나, 소스가 메시지가 도착한 링크와 다른 링크에서 등록된 경우, 서버는 해당 메시지를 조용히 무시해야 합니다.

명령은 유효한 IRC 명령이거나 ASCII 텍스트로 표현된 세 자리 숫자여야 합니다.

IRC 메시지는 항상 CR-LF(Carriage Return - Line Feed) 쌍으로 끝나는 문자 라인이며, 후행 CR-LF를 포함하여 512자를 초과해서는 안 됩니다. 따라서 명령과 매개변수에는 최대 510자가 허용됩니다. 연속 메시지 라인에 대한 규정은 없습니다. 현재 구현에 대한 자세한 내용은 7절을 참조하십시오.

#### 2.3.1 'pseudo' BNF의 메시지 형식

프로토콜 메시지는 연속적인 옥텟 스트림에서 추출되어야 합니다. 현재 해결책은 CR과 LF 두 문자를 메시지 구분자로 지정하는 것입니다. 빈 메시지는 조용히 무시되므로, 메시지 사이에 CR-LF 시퀀스를 추가적인 문제 없이 사용할 수 있습니다.

추출된 메시지는 <prefix>, <command> 및 <middle> 또는 <trailing> 컴포넌트와 일치하는 매개변수 목록으로 구문 분석됩니다.

이에 대한 BNF 표현은 다음과 같습니다:

<message>  ::= [':' <prefix> <SPACE> ] <command> <params> <crlf>
<prefix>   ::= <servername> | <nick> [ '!' <user> ] [ '@' <host> ]
<command>  ::= <letter> { <letter> } | <number> <number> <number>
<SPACE>    ::= ' ' { ' ' }
<params>   ::= <SPACE> [ ':' <trailing> | <middle> <params> ]

<middle>   ::= <SPACE나 NUL이나 CR이나 LF를 포함하지 않는 *비어있지 않은* 옥텟 시퀀스, 첫 번째는 ':'일 수 없음>
<trailing> ::= <NUL이나 CR이나 LF를 포함하지 않는, 가능한 *비어있는* 옥텟 시퀀스>

<crlf>     ::= CR LF

참고:

1) <SPACE>는 SPACE 문자(0x20)로만 구성됩니다. 특히 TABULATION과 다른 모든 제어 문자는 NON-WHITE-SPACE로 간주됩니다.

2) 매개변수 목록을 추출한 후, <middle>이나 <trailing>에 의해 일치되었는지 여부에 관계없이 모든 매개변수는 동일합니다. <Trailing>은 단순히 매개변수 내에서 SPACE를 허용하기 위한 구문적 트릭입니다.

3) CR과 LF가 매개변수 문자열에 나타날 수 없는 것은 단순히 메시지 프레임의 결과입니다. 이는 나중에 변경될 수 있습니다.

4) NUL 문자는 메시지 프레임에서 특별하지 않으며, 기본적으로 매개변수 내에 들어갈 수 있지만, 일반적인 C 문자열 처리에서 추가적인 복잡성을 유발할 수 있기 때문에 NUL은 메시지 내에서 허용되지 않습니다.

5) 마지막 매개변수는 빈 문자열일 수 있습니다.

6) 확장된 접두사(['!' <user> ] ['@' <host> ])의 사용은 서버 간 통신에서는 사용되어서는 안 되며, 추가 쿼리 없이도 메시지의 출처에 대해 클라이언트에게 더 유용한 정보를 제공하기 위한 서버-클라이언트 메시지에만 사용됩니다.

대부분의 프로토콜 메시지는 목록에서의 위치에 따라 추출된 매개변수 문자열에 대한 추가적인 의미와 구문을 지정합니다. 예를 들어, 많은 서버 명령은 명령 후의 첫 번째 매개변수가 다음과 같이 설명될 수 있는 대상 목록이라고 가정합니다:

<target>     ::= <to> [ "," <target> ]
<to>         ::= <channel> | <user> '@' <servername> | <nick> | <mask>
<channel>    ::= ('#' | '&') <chstring>
<servername> ::= <host>
<host>       ::= 허용된 호스트네임에 대한 자세한 내용은 RFC 952 [DNS:4] 참조
<nick>       ::= <letter> { <letter> | <number> | <special> }
<mask>       ::= ('#' | '$') <chstring>
<chstring>   ::= <SPACE, BELL, NUL, CR, LF 및 쉼표(',')를 제외한 모든 8비트 코드>

다른 매개변수 구문은 다음과 같습니다:

<user>       ::= <nonwhite> { <nonwhite> }
<letter>     ::= 'a' ... 'z' | 'A' ... 'Z'
<number>     ::= '0' ... '9'
<special>    ::= '-' | '[' | ']' | '\' | '`' | '^' | '{' | '}'
<nonwhite>   ::= <SPACE(0x20), NUL(0x0), CR(0xd), 및 LF(0xa)를 제외한 모든 8비트 코드>

### 2.4 숫자 응답

서버로 전송된 대부분의 메시지는 어떤 종류의 응답을 생성합니다. 가장 일반적인 응답은 오류와 일반 응답 모두에 사용되는 숫자 응답입니다. 숫자 응답은 발신자 접두사, 세 자리 숫자, 응답의 대상으로 구성된 하나의 메시지로 전송되어야 합니다. 숫자 응답은 클라이언트에서 발생할 수 없습니다. 서버가 받은 그러한 메시지는 조용히 삭제됩니다. 다른 모든 면에서 숫자 응답은 키워드가 문자열 대신 3자리 숫자로 구성된다는 점을 제외하면 일반 메시지와 동일합니다. 다양한 응답 목록은 6절에서 제공됩니다.

### 3. IRC 개념

이 섹션은 IRC 프로토콜의 조직 뒤에 있는 실제 개념을 설명하고 현재 구현이 다양한 클래스의 메시지를 어떻게 전달하는지 설명하는 데 중점을 둡니다.

                          1--\
                              A        D---4
                          2--/ \      /
                                B----C
                               /      \
                              3        E

   서버: A, B, C, D, E         클라이언트: 1, 2, 3, 4

                    [그림 2. 작은 IRC 네트워크 샘플]

#### 3.1 일대일 통신

일대일 기반의 통신은 대부분의 서버-서버 트래픽이 서버들이 서로만 이야기하는 결과가 아니기 때문에 일반적으로 클라이언트에 의해서만 수행됩니다. 클라이언트가 서로 안전하게 대화할 수 있도록 하기 위해, 모든 서버가 신장 트리를 따라 정확히 한 방향으로 메시지를 보내 모든 클라이언트에 도달할 수 있어야 합니다. 메시지가 전달되는 경로는 신장 트리의 두 점 사이의 최단 경로입니다.

다음 예제는 모두 위의 그림 2를 참조합니다:

예제 1:
     클라이언트 1과 2 사이의 메시지는 서버 A에 의해서만 보여지며, A는 이를 바로 클라이언트 2에게 전송합니다.

예제 2:
     클라이언트 1과 3 사이의 메시지는 서버 A와 B, 그리고 클라이언트 3에 의해서만 보여집니다. 다른 클라이언트나 서버는 메시지를 볼 수 없습니다.

예제 3:
     클라이언트 2와 4 사이의 메시지는 서버 A, B, C, D와 클라이언트 4에게만 보여집니다.

#### 3.2 일대다

IRC의 주요 목표는 쉽고 효율적인 회의(일대다 대화)를 위한 포럼을 제공하는 것입니다. IRC는 이를 달성하기 위한 여러 가지 수단을 제공하며, 각각은 고유한 목적을 가지고 있습니다.

##### 3.2.1 목록으로

일대다 대화의 가장 비효율적인 스타일은 클라이언트가 사용자 '목록'과 대화하는 것입니다. 이것은 거의 자명합니다: 클라이언트가 메시지를 전달할 대상 목록을 제공하면 서버는 이를 분리하고 각 지정된 대상에 개별 메시지 사본을 전송합니다. 이는 대상 목록이 분리되고 각 경로로 중복이 전송되지 않는지 확인하지 않고 발송되기 때문에 그룹을 사용하는 것만큼 효율적이지 않습니다.

##### 3.2.2 그룹으로 (채널)

IRC에서 채널은 멀티캐스트 그룹과 동등한 역할을 합니다. 채널의 존재는 동적이며(사람들이 채널에 참여하고 떠나면서 생성되고 사라짐), 채널에서 이루어지는 실제 대화는 주어진 채널에서 사용자를 지원하는 서버에만 전송됩니다. 한 서버에 같은 채널에 여러 사용자가 있는 경우, 메시지 텍스트는 해당 서버에 한 번만 전송된 다음 채널의 각 클라이언트에게 전송됩니다. 이 작업은 원래 메시지가 팬아웃되어 채널의 각 구성원에게 도달할 때까지 각 클라이언트-서버 조합에 대해 반복됩니다.

다음 예제는 모두 그림 2를 참조합니다.

예제 4:
     1명의 클라이언트가 있는 모든 채널. 채널로의 메시지는 서버로 가고 그 이상은 어디로도 가지 않습니다.

예제 5:
     채널에 2명의 클라이언트. 모든 메시지는 채널 외부에서 두 클라이언트 간의 개인 메시지인 것처럼 경로를 통과합니다.

예제 6:
     채널에 클라이언트 1, 2, 3이 있습니다. 채널로의 모든 메시지는 모든 클라이언트와 단일 클라이언트에 대한 개인 메시지인 경우 통과해야 할 서버에만 전송됩니다. 클라이언트 1이 메시지를 보내면, 클라이언트 2로 돌아가고 서버 B를 통해 클라이언트 3으로 갑니다.

#### 3.2.3 호스트/서버 마스크로

IRC 운영자에게 관련된 대규모 사용자 그룹에 메시지를 보낼 수 있는 메커니즘을 제공하기 위해, 호스트 및 서버 마스크 메시지가 제공됩니다. 이러한 메시지는 호스트나 서버 정보가 마스크와 일치하는 사용자에게 전송됩니다. 메시지는 채널과 유사한 방식으로 사용자가 있는 위치에만 전송됩니다.

#### 3.3 일대전체

일대전체 유형의 메시지는 모든 클라이언트나 서버 또는 둘 모두에 전송되는 브로드캐스트 메시지로 더 잘 설명됩니다. 대규모 사용자와 서버 네트워크에서 단일 메시지는 원하는 모든 대상에 도달하기 위해 네트워크를 통해 많은 트래픽을 발생시킬 수 있습니다.

일부 메시지의 경우, 각 서버가 보유한 상태 정보가 서버 간에 합리적으로 일관성을 유지하도록 하기 위해 모든 서버에 브로드캐스트하는 것 외에는 다른 선택이 없습니다.

##### 3.3.1 클라이언트 대 클라이언트

단일 메시지에서 다른 모든 클라이언트에게 메시지가 전송되는 메시지 클래스는 없습니다.

##### 3.3.2 클라이언트 대 서버

상태 정보 변경을 초래하는 명령(예: 채널 멤버십, 채널 모드, 사용자 상태 등) 대부분은 기본적으로 모든 서버에 전송되어야 하며, 이 배포는 클라이언트가 변경할 수 없습니다.

##### 3.3.3 서버 대 서버

서버 간 메시지 대부분은 모든 '다른' 서버에 배포되지만, 이는 사용자, 채널 또는 서버에 영향을 미치는 메시지에만 필요합니다. IRC에서 발견되는 기본 항목이 이것들이므로 서버에서 발생하는 거의 모든 메시지가 다른 모든 연결된 서버에 브로드캐스트됩니다.

### 4. 메시지 상세

다음 페이지에는 IRC 서버와 클라이언트가 인식하는 각 메시지에 대한 설명이 있습니다. 이 섹션에 설명된 모든 명령은 이 프로토콜을 위해 모든 서버에서 구현되어야 합니다.

응답 ERR_NOSUCHSERVER가 나열된 경우, <server> 매개변수를 찾을 수 없다는 의미입니다. 서버는 그 명령에 대해 다른 응답을 보내서는 안 됩니다.

클라이언트가 연결된 서버는 완전한 메시지를 구문 분석하고 적절한 오류를 반환해야 합니다. 서버가 메시지를 구문 분석하는 동안 치명적인 오류가 발생하면, 오류를 클라이언트에 다시 보내고 구문 분석을 종료해야 합니다. 치명적인 오류는 잘못된 명령, 서버에 알려지지 않은 대상(서버, 닉 또는 채널 이름이 이 범주에 속함), 매개변수가 충분하지 않거나 잘못된 권한 등으로 간주될 수 있습니다.

완전한 매개변수 세트가 제시되면, 각각의 유효성을 검사하고 적절한 응답을 클라이언트에 다시 보내야 합니다. 쉼표를 항목 구분자로 사용하는 매개변수 목록을 사용하는 메시지의 경우, 각 항목에 대한 응답을 보내야 합니다.

아래 예제에서 일부 메시지는 전체 형식을 사용하여 나타납니다:

   :Name COMMAND parameter list

이러한 예제는 메시지가 전송되는 동안 서버 간에 "Name"에서 발생한 메시지를 나타내며, 여기서 원격 서버가 올바른 경로를 따라 응답을 다시 보낼 수 있도록 메시지의 원래 발신자의 이름을 포함하는 것이 필수적입니다.

### 4.1 연결 등록

여기서 설명하는 명령은 사용자나 서버로서 IRC 서버에 연결을 등록하고 올바르게 연결을 해제하는 데 사용됩니다.

클라이언트나 서버 연결이 등록되기 위해 "PASS" 명령이 필요하지는 않지만, server 메시지나 NICK/USER 조합 중 후자보다 먼저 와야 합니다. 실제 연결에 일정 수준의 보안을 제공하기 위해 모든 서버 연결에 비밀번호를 사용하는 것이 강력히 권장됩니다. 클라이언트가 등록하는 데 권장되는 순서는 다음과 같습니다:

           1. Pass 메시지
           2. Nick 메시지
           3. User 메시지

#### 4.1.1 Password 메시지

      명령: PASS
   매개변수: <password>

PASS 명령은 '연결 비밀번호'를 설정하는 데 사용됩니다. 연결 등록을 시도하기 전에 비밀번호를 설정할 수 있고 설정해야 합니다. 현재 이는 클라이언트가 NICK/USER 조합을 보내기 전에 PASS 명령을 보내야 하고 서버는 모든 SERVER 명령 전에 PASS 명령을 *반드시* 보내야 함을 의미합니다. 제공된 비밀번호는 C/N 라인(서버의 경우) 또는 I 라인(클라이언트의 경우)에 포함된 것과 일치해야 합니다. 등록하기 전에 여러 PASS 명령을 보내는 것이 가능하지만 마지막으로 보낸 것만 확인에 사용되며 등록 후에는 변경할 수 없습니다.

숫자 응답:
           ERR_NEEDMOREPARAMS              ERR_ALREADYREGISTRED

예제:
           PASS secretpasswordhere

#### 4.1.2 Nickname 메시지

      명령: NICK
   매개변수: <nickname> [ <hopcount> ]

NICK 메시지는 사용자에게 닉네임을 부여하거나 이전 닉네임을 변경하는 데 사용됩니다. <hopcount> 매개변수는 서버에서만 사용되어 닉네임이 홈 서버에서 얼마나 멀리 떨어져 있는지를 나타냅니다. 로컬 연결의 hopcount는 0입니다. 클라이언트가 제공한 경우 무시되어야 합니다.

다른 클라이언트에 대해 동일한 닉네임을 이미 알고 있는 서버에 NICK 메시지가 도착하면 닉네임 충돌이 발생합니다. 닉네임 충돌의 결과로, 닉네임의 모든 인스턴스가 서버의 데이터베이스에서 제거되고, KILL 명령이 발행되어 다른 모든 서버의 데이터베이스에서 닉네임을 제거합니다. 충돌을 일으킨 NICK 메시지가 닉네임 변경이었다면 원래(이전) 닉도 제거되어야 합니다.

서버가 직접 연결된 클라이언트로부터 동일한 NICK을 받으면, 로컬 클라이언트에 ERR_NICKCOLLISION을 발행하고 NICK 명령을 삭제하며 kill을 생성하지 않을 수 있습니다.

숫자 응답:
           ERR_NONICKNAMEGIVEN             ERR_ERRONEUSNICKNAME
           ERR_NICKNAMEINUSE               ERR_NICKCOLLISION

예제:
   NICK Wiz                        ; 새로운 닉 "Wiz" 소개

   :WiZ NICK Kilroy                ; WiZ가 자신의 닉네임을 Kilroy로 변경

#### 4.1.3 User 메시지

      명령: USER
   매개변수: <username> <hostname> <servername> <realname>

USER 메시지는 연결 시작 시 새로운 사용자의 사용자 이름, 호스트 이름, 서버 이름 및 실제 이름을 지정하는 데 사용됩니다. 또한 IRC에 새로 도착한 사용자를 나타내기 위해 서버 간 통신에서도 사용됩니다. USER와 NICK이 모두 클라이언트로부터 수신된 후에만 사용자가 등록되기 때문입니다.

서버 간에는 USER가 클라이언트의 NICKNAME으로 접두사가 붙어야 합니다. USER 명령이 직접 연결된 클라이언트에서 올 때 hostname과 servername은 일반적으로 IRC 서버에서 (보안상의 이유로) 무시되지만, 서버 간 통신에서는 사용됩니다. 이는 새로운 사용자가 나머지 네트워크에 소개될 때 동반되는 USER를 보내기 전에 항상 NICK을 원격 서버에 보내야 함을 의미합니다.

realname 매개변수는 공백 문자를 포함할 수 있고 이것이 마지막 매개변수로 인식되도록 하기 위해 콜론(':')을 접두사로 붙여야 한다는 점에 주의해야 합니다.

USER 메시지에만 의존하여 사용자가 자신의 사용자 이름에 대해 거짓말하기 쉽기 때문에 "Identity Server" 사용이 권장됩니다. 사용자가 연결하는 호스트에 그러한 서버가 활성화되어 있으면 사용자 이름은 "Identity Server"의 응답과 같이 설정됩니다.

숫자 응답:
           ERR_NEEDMOREPARAMS              ERR_ALREADYREGISTRED

예제:
   USER guest tolmoon tolsun :Ronnie Reagan
                                   ; "guest"라는 사용자 이름과 실제 이름
                                   "Ronnie Reagan"으로 자신을 등록하는 사용자

   :testnick USER guest tolmoon tolsun :Ronnie Reagan
                                   ; USER 명령이 속한 닉네임과 함께 서버
                                   간의 메시지

#### 4.1.4 Server 메시지

      명령: SERVER
   매개변수: <servername> <hopcount> <info>

SERVER 메시지는 새로운 연결의 다른 쪽 끝이 서버임을 서버에 알리는 데 사용됩니다. 이 메시지는 또한 전체 네트워크에 서버 데이터를 전달하는 데 사용됩니다. 새로운 서버가 네트워크에 연결되면, 그에 대한 정보가 전체 네트워크에 브로드캐스트됩니다. <hopcount>는 모든 서버에게 모든 서버가 얼마나 멀리 떨어져 있는지에 대한 내부 정보를 제공하는 데 사용됩니다. 전체 서버 목록이 있으면 전체 서버 트리의 지도를 구성할 수 있지만, hostmask가 이를 방지합니다.

SERVER 메시지는 (a) 아직 등록되지 않았고 서버로 등록하려고 시도하는 연결이나 (b) 다른 서버에 대한 기존 연결에서만 수락되어야 하며, 이 경우 SERVER 메시지는 해당 서버 뒤에 있는 새로운 서버를 소개합니다.

SERVER 명령 수신과 함께 발생하는 대부분의 오류는 대상 호스트(대상 SERVER)에 의해 연결이 종료되는 결과를 초래합니다. 오류 응답은 일반적으로 ERROR 명령에 몇 가지 유용한 속성이 있어 여기서 유용하기 때문에 숫자 대신 "ERROR" 명령을 사용하여 전송됩니다.

SERVER 메시지가 구문 분석되고 수신 서버에 이미 알려진 서버를 소개하려고 시도하는 경우, 서버에 대한 중복 경로가 형성되고 IRC 트리의 비순환적 특성이 깨졌기 때문에 해당 메시지가 온 연결은 (올바른 절차에 따라) 닫혀야 합니다.

숫자 응답:
           ERR_ALREADYREGISTRED

예제:

SERVER test.oulu.fi 1 :[tolsun.oulu.fi] Experimental server
                                ; 새로운 서버 test.oulu.fi가 자신을
                                소개하고 등록을 시도합니다. []안의
                                이름은 test.oulu.fi를 실행하는
                                호스트의 호스트네임입니다.

:tolsun.oulu.fi SERVER csd.bu.edu 5 :BU Central Server
                                ; 서버 tolsun.oulu.fi는 5 홉 떨어진
                                csd.bu.edu에 대한 우리의 업링크입니다.

#### 4.1.5 Operator 메시지

      명령: OPER
   매개변수: <user> <password>

OPER 메시지는 일반 사용자가 운영자 권한을 얻기 위해 사용됩니다. 주어진 사용자에 대한 <user>와 <password>의 조합이 운영자 권한을 얻는 데 필요합니다.

OPER 명령을 보내는 클라이언트가 주어진 사용자에 대해 올바른 비밀번호를 제공하면, 서버는 클라이언트의 닉네임에 대해 "MODE +o"를 발행하여 네트워크의 나머지 부분에 새로운 운영자를 알립니다.

OPER 메시지는 클라이언트-서버 전용입니다.

숫자 응답:
           ERR_NEEDMOREPARAMS              RPL_YOUREOPER
           ERR_NOOPERHOST                  ERR_PASSWDMISMATCH

예제:
   OPER foo bar                    ; "foo"라는 사용자 이름과 "bar"를
                                   비밀번호로 사용하여 운영자로 등록을
                                   시도합니다.

#### 4.1.6 Quit 메시지

      명령: QUIT
   매개변수: [<Quit message>]

클라이언트 세션은 quit 메시지로 종료됩니다. 서버는 QUIT 메시지를 보내는 클라이언트와의 연결을 닫아야 합니다. "Quit Message"가 제공되면 기본 메시지인 닉네임 대신 이 메시지가 전송됩니다.

네트스플릿(두 서버의 연결 해제)이 발생할 때, quit 메시지는 공백으로 구분된 관련된 두 서버의 이름으로 구성됩니다. 첫 번째 이름은 여전히 연결된 서버의 이름이고 두 번째 이름은 연결이 끊긴 서버의 이름입니다.

다른 이유로 클라이언트가 QUIT 명령을 발행하지 않고 클라이언트 연결이 닫히는 경우(예: 클라이언트가 죽고 소켓에서 EOF가 발생), 서버는 그것을 발생시킨 이벤트의 특성을 반영하는 일종의 메시지로 quit 메시지를 채워야 합니다.

숫자 응답:
           없음

예제:
   QUIT :Gone to have lunch        ; 선호되는 메시지 형식

#### 4.1.7 Server quit 메시지

      명령: SQUIT
   매개변수: <server> <comment>

SQUIT 메시지는 종료하거나 죽은 서버에 대해 알리는 데 필요합니다. 서버가 다른 서버와의 연결을 끊고 싶다면 다른 서버의 이름을 서버 매개변수로 사용하여 SQUIT 메시지를 해당 서버에 보내야 하며, 이후 종료하는 서버와의 연결을 닫습니다.

이 명령은 IRC 서버의 네트워크가 질서 있게 연결되도록 유지하는 데 도움이 되도록 운영자도 사용할 수 있습니다. 운영자는 또한 원격 서버 연결에 대한 SQUIT 메시지를 발행할 수 있습니다. 이 경우, SQUIT는 운영자와 원격 서버 사이의 각 서버에서 아래 설명된 대로 네트워크에 대한 각 서버의 시각을 업데이트하면서 구문 분석되어야 합니다.

<comment>는 다른 운영자들이 이 조치의 이유를 알 수 있도록 원격 서버(현재 있는 서버에 연결되지 않은)에 대해 SQUIT를 실행하는 모든 운영자가 제공해야 합니다. <comment>는 오류나 유사한 메시지를 여기에 넣을 수 있는 서버에 의해서도 채워집니다.

닫히는 연결의 양쪽에 있는 두 서버 모두 해당 링크 뒤에 있다고 간주되는 다른 모든 서버에 대해 SQUIT 메시지를 (다른 모든 서버 연결에) 보내야 합니다.

마찬가지로, 해당 링크 뒤에 있는 모든 클라이언트를 대신하여 QUIT 메시지를 네트워크의 다른 연결된 서버에 보내야 합니다. 또한 분할로 인해 구성원을 잃은 채널의 모든 채널 구성원에게 QUIT 메시지를 보내야 합니다.

서버 연결이 조기에 종료되는 경우(예: 링크의 다른 쪽 끝에 있는 서버가 죽은 경우), 이 연결 해제를 감지하는 서버는 연결이 닫혔다는 것을 네트워크의 나머지 부분에 알리고 적절한 내용으로 comment 필드를 채워야 합니다.

숫자 응답:
           ERR_NOPRIVILEGES                ERR_NOSUCHSERVER

예제:
   SQUIT tolsun.oulu.fi :Bad Link ? ; 서버 링크 tolson.oulu.fi가
                                   "Bad Link" 때문에 종료되었습니다.

   :Trillian SQUIT cm22.eng.umd.edu :Server out of control
                                    ; "Server out of control" 때문에
                                   "cm22.eng.umd.edu"를 네트워크에서
                                   연결 해제하라는 Trillian의 메시지

### 4.2 채널 운영

이 메시지 그룹은 채널, 채널의 속성(채널 모드) 및 그 내용(일반적으로 클라이언트)을 조작하는 것과 관련이 있습니다. 이를 구현할 때, 네트워크의 반대쪽 끝에 있는 클라이언트가 결국 충돌할 명령을 보낼 때 많은 경쟁 조건이 불가피합니다. 또한 서버가 닉네임 변경 내역을 유지하여 서버가 그것들을 조작하는 명령과 함께 닉네임 변경 경쟁 조건이 발생할 때 상황을 따라잡을 기회를 가질 수 있도록 하는 것이 필요합니다.

#### 4.2.1 Join 메시지

      명령: JOIN
   매개변수: <channel>{,<channel>} [<key>{,<key>}]

JOIN 명령은 클라이언트가 특정 채널의 청취를 시작하는 데 사용됩니다. 클라이언트가 채널에 참여할 수 있는지 여부는 클라이언트가 연결된 서버에서만 확인됩니다. 다른 모든 서버는 다른 서버로부터 받았을 때 자동으로 사용자를 채널에 추가합니다. 이에 영향을 미치는 조건은 다음과 같습니다:

           1. 채널이 초대 전용인 경우 사용자는 초대를 받아야 합니다;

           2. 사용자의 nick/username/hostname이 활성 차단과 일치하지 않아야 합니다;

           3. 설정된 경우 올바른 키(비밀번호)를 제공해야 합니다.

이에 대해서는 MODE 명령에서 더 자세히 설명합니다(자세한 내용은 4.2.3절 참조).

사용자가 채널에 가입하면, 서버가 채널에 영향을 미치는 받은 모든 명령에 대한 통지를 받습니다. 여기에는 MODE, KICK, PART, QUIT 및 물론 PRIVMSG/NOTICE가 포함됩니다. JOIN 명령은 각 서버가 채널에 있는 사용자를 어디서 찾을 수 있는지 알 수 있도록 모든 서버에 브로드캐스트되어야 합니다. 이를 통해 채널에 대한 PRIVMSG/NOTICE의 최적 전달이 가능합니다.

JOIN이 성공하면, 사용자는 채널의 주제(RPL_TOPIC 사용)와 채널에 있는 사용자 목록(RPL_NAMREPLY 사용)을 받게 되며, 여기에는 참여하는 사용자가 포함되어야 합니다.

숫자 응답:
           ERR_NEEDMOREPARAMS              ERR_BANNEDFROMCHAN
           ERR_INVITEONLYCHAN              ERR_BADCHANNELKEY
           ERR_CHANNELISFULL               ERR_BADCHANMASK
           ERR_NOSUCHCHANNEL               ERR_TOOMANYCHANNELS
           RPL_TOPIC

예제:
   JOIN #foobar                    ; 채널 #foobar 참여

   JOIN &foo fubar                 ; 키 "fubar"를 사용하여 채널 &foo 참여

   JOIN #foo,&bar fubar            ; 키 "fubar"를 사용하여 채널 #foo 참여 및
                                   키 없이 &bar 참여

   JOIN #foo,#bar fubar,foobar     ; 키 "fubar"를 사용하여 채널 #foo 참여
                                   및 키 "foobar"를 사용하여 채널 #bar 참여

   JOIN #foo,#bar                  ; 채널 #foo와 #bar 참여

   :WiZ JOIN #Twilight_zone        ; WiZ의 JOIN 메시지

#### 4.2.2 Part 메시지

      명령: PART
   매개변수: <channel>{,<channel>}

PART 메시지는 메시지를 보내는 클라이언트를 매개변수 문자열에 나열된 모든 주어진 채널의 활성 사용자 목록에서 제거하게 합니다.

숫자 응답:
           ERR_NEEDMOREPARAMS              ERR_NOSUCHCHANNEL
           ERR_NOTONCHANNEL

예제:
   PART #twilight_zone             ; 채널 "#twilight_zone" 떠나기

   PART #oz-ops,&group5            ; "&group5"와 "#oz-ops" 채널 모두 떠나기

#### 4.2.3 Mode 메시지

      명령: MODE

MODE 명령은 IRC에서 이중 목적 명령입니다. 사용자 이름과 채널 모두 모드를 변경할 수 있습니다. 이러한 선택의 근거는 언젠가 닉네임이 구식이 될 것이고 그에 상응하는 속성이 채널이 될 것이기 때문입니다.

MODE 메시지를 구문 분석할 때, 먼저 전체 메시지를 구문 분석한 다음 그 결과로 발생한 변경 사항을 전달하는 것이 권장됩니다.

##### 4.2.3.1 채널 모드

   매개변수: <channel> {[+|-]|o|p|s|i|t|n|b|v} [<limit>] [<user>]
            [<ban mask>]

MODE 명령은 채널 운영자가 '자신의' 채널의 특성을 변경할 수 있도록 제공됩니다. 또한 채널 운영자가 생성될 수 있도록 서버가 채널 모드를 변경할 수 있어야 합니다.

채널에 사용할 수 있는 다양한 모드는 다음과 같습니다:

           o - 채널 운영자 권한 부여/제거;
           p - 비공개 채널 플래그;
           s - 비밀 채널 플래그;
           i - 초대 전용 채널 플래그;
           t - 채널 운영자만 주제 설정 가능 플래그;
           n - 외부 클라이언트의 채널 메시지 금지;
           m - 중재된 채널;
           l - 채널의 사용자 제한 설정;
           b - 사용자를 제외하기 위한 차단 마스크 설정;
           v - 중재된 채널에서 발언 능력 부여/제거;
           k - 채널 키(비밀번호) 설정.

'o'와 'b' 옵션을 사용할 때, mode 명령당 총 세 개의 제한이 부과되었습니다. 즉, 'o'와 'b'의 모든 조합에서 최대 3개만 허용됩니다.

##### 4.2.3.2 사용자 모드

   매개변수: <nickname> {[+|-]|i|w|s|o}

사용자 MODE는 일반적으로 클라이언트가 다른 사람에게 어떻게 보이는지 또는 클라이언트가 받는 '추가' 메시지에 영향을 미치는 변경 사항입니다. 사용자 MODE 명령은 메시지 발신자와 매개변수로 주어진 닉네임이 모두 동일한 경우에만 수락될 수 있습니다.

사용 가능한 모드는 다음과 같습니다:

           i - 사용자를 보이지 않음으로 표시;
           s - 서버 알림 수신을 위해 사용자 표시;
           w - 사용자가 wallops 수신;
           o - 운영자 플래그.

나중에 추가 모드를 사용할 수 있습니다.

사용자가 "+o" 플래그를 사용하여 자신을 운영자로 만들려고 시도하면, 그 시도는 무시되어야 합니다. 그러나 누구나 자신을 'deop'하는 것("-o" 사용)에는 제한이 없습니다.

숫자 응답:
           ERR_NEEDMOREPARAMS              RPL_CHANNELMODEIS
           ERR_CHANOPRIVSNEEDED            ERR_NOSUCHNICK
           ERR_NOTONCHANNEL                ERR_KEYSET
           RPL_BANLIST                     RPL_ENDOFBANLIST
           ERR_UNKNOWNMODE                 ERR_NOSUCHCHANNEL

           ERR_USERSDONTMATCH              RPL_UMODEIS
           ERR_UMODEUNKNOWNFLAG

예제:
           채널 모드 사용:

MODE #Finnish +im               ; #Finnish 채널을 중재되고
                                '초대 전용'으로 만듦

MODE #Finnish +o Kilroy         ; #Finnish 채널에서 Kilroy에게
                                '채널 운영자' 권한 부여

MODE #Finnish +v Wiz            ; #Finnish에서 WiZ의 발언 허용

MODE #Fins -s                   ; #Fins 채널에서 '비밀' 플래그 제거

MODE #42 +k oulu                ; 채널 키를 "oulu"로 설정

MODE #eu-opers +l 10            ; 채널의 사용자 수 제한을
                                10으로 설정

MODE &oulu +b                   ; 채널에 설정된 차단 마스크 나열

MODE &oulu +b *!*@*             ; 모든 사용자의 참여 방지

MODE &oulu +b *!*@*.edu         ; *.edu와 일치하는 호스트네임을 가진
                                모든 사용자의 참여 방지

        사용자 모드 사용:

:MODE WiZ -w                    ; WiZ의 WALLOPS 메시지 수신
                                끄기

:Angel MODE Angel +i            ; 자신을 보이지 않게 만들기 위한
                                Angel의 메시지

MODE WiZ -o                     ; WiZ의 'deoping'(운영자
                                상태 제거). 이 명령의 단순한 반대
                                ("MODE WiZ +o")는 OPER 명령을
                                우회하므로 사용자에게서 허용되어서는
                                안 됩니다.

#### 4.2.4 Topic 메시지

      명령: TOPIC
   매개변수: <channel> [<topic>]

TOPIC 메시지는 채널의 주제를 변경하거나 보는 데 사용됩니다. <topic>이 주어지지 않은 경우 <channel>의 주제가 반환됩니다. <topic> 매개변수가 있는 경우, 채널 모드가 이 작업을 허용한다면 해당 채널의 주제가 변경됩니다.

숫자 응답:
           ERR_NEEDMOREPARAMS              ERR_NOTONCHANNEL
           RPL_NOTOPIC                     RPL_TOPIC
           ERR_CHANOPRIVSNEEDED

예제:
   :Wiz TOPIC #test :New topic     ;사용자 Wiz가 주제를 설정.

   TOPIC #test :another topic      ;#test의 주제를 "another topic"으로 설정.

   TOPIC #test                     ;#test의 주제 확인.

#### 4.2.5 Names 메시지

      명령: NAMES
   매개변수: [<channel>{,<channel>}]

NAMES 명령을 사용하여, 사용자는 볼 수 있는 모든 채널에서 볼 수 있는 모든 닉네임을 나열할 수 있습니다. 볼 수 있는 채널 이름은 비공개(+p)나 비밀(+s)이 아니거나 실제로 사용자가 있는 채널입니다. <channel> 매개변수는 유효한 경우 정보를 반환할 채널을 지정합니다. 잘못된 채널 이름에 대한 오류 응답은 없습니다.

<channel> 매개변수가 주어지지 않으면, 모든 채널과 그 구성원의 목록이 반환됩니다. 이 목록의 끝에서, 보이지만 채널에 없거나 보이는 채널에 없는 사용자들은 '*' '채널'에 있는 것으로 나열됩니다.

숫자:
           RPL_NAMREPLY                    RPL_ENDOFNAMES

예제:
   NAMES #twilight_zone,#42        ;채널이 보이는 경우 #twilight_zone과
                                   #42의 보이는 사용자 나열.

   NAMES                           ;모든 보이는 채널과 사용자 나열

#### 4.2.6 List 메시지

      명령: LIST
   매개변수: [<channel>{,<channel>} [<server>]]

LIST 메시지는 채널과 그 주제를 나열하는 데 사용됩니다. <channel> 매개변수가 사용되면, 해당 채널의 상태만 표시됩니다. 쿼리를 생성하는 클라이언트가 실제로 해당 채널에 있지 않는 한 비공개 채널은 주제 없이 채널 "Prv"로 나열됩니다. 마찬가지로, 클라이언트가 해당 채널의 구성원이 아닌 한 비밀 채널은 전혀 나열되지 않습니다.

숫자 응답:
           ERR_NOSUCHSERVER                RPL_LISTSTART
           RPL_LIST                        RPL_LISTEND

예제:
   LIST                            ;모든 채널 나열.

   LIST #twilight_zone,#42         ;채널 #twilight_zone과 #42 나열

#### 4.2.7 Invite 메시지

      명령: INVITE
   매개변수: <nickname> <channel>

INVITE 메시지는 사용자를 채널에 초대하는 데 사용됩니다. <nickname> 매개변수는 대상 채널 <channel>에 초대될 사람의 닉네임입니다. 대상 사용자가 초대되는 채널이 존재하거나 유효한 채널이어야 한다는 요구 사항은 없습니다. 초대 전용인 채널(MODE +i)에 대상 사용자를 초대하려면, 초대를 보내는 클라이언트가 해당 채널의 채널 운영자로 인정되어야 합니다.

숫자 응답:
           ERR_NEEDMOREPARAMS              ERR_NOSUCHNICK
           ERR_NOTONCHANNEL                ERR_USERONCHANNEL
           ERR_CHANOPRIVSNEEDED
           RPL_INVITING                    RPL_AWAY

예제:
   :Angel INVITE Wiz #Dust         ;사용자 Angel이 WiZ를 채널
                                   #Dust에 초대

   INVITE Wiz #Twilight_Zone       ;WiZ를 #Twilight_zone에
                                   초대하는 명령

#### 4.2.8 Kick 명령

      명령: KICK
   매개변수: <channel> <user> [<comment>]

KICK 명령은 사용자를 강제로 채널에서 제거하는 데 사용할 수 있습니다. 즉, 채널에서 '강제 퇴장'시킵니다(강제 PART). 채널 운영자만이 다른 사용자를 채널에서 강제 퇴장시킬 수 있습니다. KICK 메시지를 받는 각 서버는 희생자를 채널에서 제거하기 전에 유효한지(즉, 발신자가 실제로 채널 운영자인지) 확인합니다.

숫자 응답:
           ERR_NEEDMOREPARAMS              ERR_NOSUCHCHANNEL
           ERR_BADCHANMASK                 ERR_CHANOPRIVSNEEDED
           ERR_NOTONCHANNEL

예제:
KICK &Melbourne Matthew         ; Matthew를 &Melbourne에서 강제 퇴장

KICK #Finnish John :Speaking English
                                ; "Speaking English"를 이유(댓글)로
                                John을 #Finnish에서 강제 퇴장

:WiZ KICK #Finnish John         ; John을 채널 #Finnish에서 제거하기 위한
                                WiZ의 KICK 메시지

참고:
     KICK 명령 매개변수를 다음과 같이 확장하는 것이 가능합니다:

<channel>{,<channel>} <user>{,<user>} [<comment>]

### 4.3 서버 쿼리와 명령

서버 쿼리 그룹의 명령은 네트워크에 연결된 모든 서버에 대한 정보를 반환하도록 설계되었습니다. 연결된 모든 서버는 이러한 쿼리에 응답해야 하며 올바르게 응답해야 합니다. 유효하지 않은 응답(또는 응답 부재)은 서버가 고장났다는 신호로 간주되어야 하며, 상황이 해결될 때까지 가능한 한 빨리 연결 해제/비활성화되어야 합니다.

이러한 쿼리에서 매개변수가 "<server>"로 나타나는 경우, 일반적으로 닉네임이나 서버 또는 일종의 와일드카드 이름이 될 수 있음을 의미합니다. 그러나 각 매개변수에 대해 하나의 쿼리와 응답 세트만 생성되어야 합니다.

#### 4.3.1 Version 메시지

      명령: VERSION
   매개변수: [<server>]

VERSION 메시지는 서버 프로그램의 버전을 쿼리하는 데 사용됩니다. 선택적 매개변수 <server>는 클라이언트가 직접 연결되지 않은 서버 프로그램의 버전을 쿼리하는 데 사용됩니다.

숫자 응답:
           ERR_NOSUCHSERVER                RPL_VERSION

예제:
   :Wiz VERSION *.se               ; "*.se"와 일치하는 서버의 버전을
                                   확인하기 위한 Wiz의 메시지

   VERSION tolsun.oulu.fi          ; 서버 "tolsun.oulu.fi"의 버전 확인

#### 4.3.2 Stats 메시지

      명령: STATS
   매개변수: [<query> [<server>]]

STATS 메시지는 특정 서버의 통계를 쿼리하는 데 사용됩니다. <server> 매개변수가 생략되면 통계 응답의 끝만 다시 보내집니다. 이 명령의 구현은 응답하는 서버에 따라 매우 다르지만, 서버는 아래 쿼리(또는 유사한)에 의해 설명된 정보를 제공할 수 있어야 합니다.

쿼리는 대상 서버(만약 <server> 매개변수로 주어진 경우)에서만 확인하고 중간 서버에서는 전달되고 무시되며 변경되지 않는 단일 문자로 제공될 수 있습니다. 다음 쿼리는 현재 IRC 구현에서 발견된 것으로, 해당 서버의 설정 정보의 상당 부분을 제공합니다. 이러한 것들이 다른 버전에서 동일한 방식으로 지원되지 않을 수 있지만, 모든 서버는 쿼리의 목적과 현재 사용되는 응답 형식과 일관된 STATS 쿼리에 대한 유효한 응답을 제공할 수 있어야 합니다.

현재 지원되는 쿼리는 다음과 같습니다:

           c - 서버가 연결할 수 있거나 연결을 허용할 수 있는 서버 목록 반환;
           h - leaf로 취급되거나 hub로 작동할 수 있는 서버 목록 반환;
           i - 서버가 클라이언트가 연결할 수 있도록 허용하는 호스트 목록 반환;
           k - 해당 서버에 대한 금지된 사용자 이름/호스트 이름 조합 목록 반환;
           l - 서버의 연결 목록 반환, 각 연결이 얼마나 오래 설정되었는지와 각 방향의
               바이트 및 메시지로 측정된 해당 연결의 트래픽을 표시;
           m - 서버가 지원하는 명령 목록과 사용 횟수가 0이 아닌 경우 각 명령의
               사용 횟수 반환;
           o - 일반 클라이언트가 운영자가 될 수 있는 호스트 목록 반환;
           y - 서버의 설정 파일에서 Y(Class) 라인 표시;
           u - 서버가 얼마나 오래 실행되었는지 보여주는 문자열 반환.

숫자 응답:
           ERR_NOSUCHSERVER
           RPL_STATSCLINE                  RPL_STATSNLINE
           RPL_STATSILINE                  RPL_STATSKLINE
           RPL_STATSQLINE                  RPL_STATSLLINE
           RPL_STATSLINKINFO               RPL_STATSUPTIME
           RPL_STATSCOMMANDS               RPL_STATSOLINE
           RPL_STATSHLINE                  RPL_ENDOFSTATS

예제:
STATS m                         ; 연결된 서버의 명령 사용 확인

:Wiz STATS c eff.org            ; 서버 eff.org의 C/N 라인 정보에 대한
                                WiZ의 요청

#### 4.3.3 Links 메시지

      명령: LINKS
   매개변수: [[<remote server>] <server mask>]

LINKS를 사용하여 사용자는 쿼리에 응답하는 서버가 알고 있는 모든 서버를 나열할 수 있습니다. 반환된 서버 목록은 마스크와 일치해야 하며, 마스크가 주어지지 않은 경우 전체 목록이 반환됩니다.

<remote server>가 <server mask>와 함께 주어진 경우, LINKS 명령은 해당 이름과 일치하는 첫 번째 서버(있는 경우)로 전달되고, 해당 서버는 쿼리에 응답해야 합니다.

숫자 응답:
           ERR_NOSUCHSERVER
           RPL_LINKS                       RPL_ENDOFLINKS

예제:
LINKS *.au                      ; *.au와 일치하는 이름을 가진 모든
                                서버 나열;

:WiZ LINKS *.bu.edu *.edu       ; *.edu와 일치하는 첫 번째 서버에
                                *.bu.edu와 일치하는 서버 목록을 요청하는
                                WiZ의 LINKS 메시지.

#### 4.3.4 Time 메시지

      명령: TIME
   매개변수: [<server>]

TIME 메시지는 지정된 서버의 로컬 시간을 쿼리하는 데 사용됩니다. 서버 매개변수가 주어지지 않은 경우, 명령을 처리하는 서버가 쿼리에 응답해야 합니다.

숫자 응답:
           ERR_NOSUCHSERVER                RPL_TIME

예제:
   TIME tolsun.oulu.fi             ; 서버 "tolson.oulu.fi"의 시간 확인

   Angel TIME *.au                 ; "*.au"와 일치하는 서버의 시간을
                                   확인하는 사용자 angel

#### 4.3.5 Connect 메시지

      명령: CONNECT
   매개변수: <target server> [<port> [<remote server>]]

CONNECT 명령은 서버가 다른 서버와 즉시 새로운 연결을 설정하도록 강제할 수 있습니다. CONNECT는 특권 명령이며 IRC 운영자만 사용할 수 있어야 합니다. 원격 서버가 주어진 경우, CONNECT 시도는 해당 서버에 의해 <target server>와 <port>로 이루어집니다.

숫자 응답:
           ERR_NOSUCHSERVER                ERR_NOPRIVILEGES
           ERR_NEEDMOREPARAMS

예제:
CONNECT tolsun.oulu.fi          ; 서버를 tolsun.oulu.fi에 연결
                                시도

:WiZ CONNECT eff.org 6667 csd.bu.edu
                                ; WiZ가 서버 eff.org와 csd.bu.edu를
                                포트 6667로 연결하도록 시도하는 
                                CONNECT 메시지.

#### 4.3.6 Trace 메시지

      명령: TRACE
   매개변수: [<server>]

TRACE 명령은 특정 서버로 가는 경로를 찾는 데 사용됩니다. 이 메시지를 처리하는 각 서버는 통과 링크임을 나타내는 응답을 보내서 발신자에게 알려야 하며, "traceroute" 사용에서 얻은 것과 유사한 응답 체인을 형성합니다. 이 응답을 다시 보낸 후, 주어진 서버에 도달할 때까지 다음 서버로 TRACE 메시지를 보내야 합니다. <server> 매개변수가 생략된 경우, TRACE 명령이 현재 서버가 직접 연결된 서버를 발신자에게 알리는 메시지를 보내는 것이 권장됩니다.

"<server>"로 주어진 대상이 실제 서버인 경우, 대상 서버는 자신에게 연결된 모든 서버와 사용자를 보고해야 하지만, 운영자만이 현재 있는 사용자를 볼 수 있습니다. <server>가 닉네임인 경우, 해당 닉네임에 대한 응답만 제공됩니다.

숫자 응답:
           ERR_NOSUCHSERVER

TRACE 메시지가 다른 서버로 향하는 경우, 모든 중간 서버는 TRACE가 통과했음을 나타내고 다음에 어디로 가는지를 나타내기 위해 RPL_TRACELINK 응답을 반환해야 합니다.

           RPL_TRACELINK

TRACE 응답은 다음 숫자 응답 중 어떤 것이든 포함할 수 있습니다.

           RPL_TRACECONNECTING             RPL_TRACEHANDSHAKE
           RPL_TRACEUNKNOWN                RPL_TRACEOPERATOR
           RPL_TRACEUSER                   RPL_TRACESERVER
           RPL_TRACESERVICE                RPL_TRACENEWTYPE
           RPL_TRACECLASS

예제:
TRACE *.oulu.fi                 ; *.oulu.fi와 일치하는 서버 TRACE

:WiZ TRACE AngelDust            ; 닉네임 AngelDust에 대한 WiZ의 TRACE

#### 4.3.7 Admin 명령

      명령: ADMIN
   매개변수: [<server>]

ADMIN 메시지는 주어진 서버의 관리자 이름을 찾거나, <server> 매개변수가 생략된 경우 현재 서버의 관리자 이름을 찾는 데 사용됩니다. 각 서버는 ADMIN 메시지를 다른 서버로 전달할 수 있어야 합니다.

숫자 응답:
           ERR_NOSUCHSERVER
           RPL_ADMINME                     RPL_ADMINLOC1
           RPL_ADMINLOC2                   RPL_ADMINEMAIL

예제:
   ADMIN tolsun.oulu.fi            ; tolsun.oulu.fi에 ADMIN 응답 요청

   :WiZ ADMIN *.edu                ; *.edu와 일치하는 첫 번째 서버에 대한
                                   WiZ의 ADMIN 요청.

#### 4.3.8 Info 명령

      명령: INFO
   매개변수: [<server>]

INFO 명령은 서버를 설명하는 정보를 반환해야 합니다: 버전, 컴파일된 시기, 패치 레벨, 시작된 시기, 그리고 관련이 있다고 간주될 수 있는 기타 모든 잡다한 정보.

숫자 응답:
           ERR_NOSUCHSERVER
           RPL_INFO                        RPL_ENDOFINFO

예제:
   INFO csd.bu.edu                 ; csd.bu.edu에 INFO 응답 요청

   :Avalon INFO *.fi               ; *.fi와 일치하는 첫 번째 서버에 대한
                                   Avalon의 INFO 요청.
   INFO Angel                      ; Angel이 연결된 서버에 대한 정보 요청.

### 4.4 메시지 보내기

IRC 프로토콜의 주요 목적은 클라이언트가 서로 통신할 수 있는 기반을 제공하는 것입니다. PRIVMSG와 NOTICE는 한 클라이언트에서 다른 클라이언트로 텍스트 메시지를 실제로 전달할 수 있는 유일한 메시지입니다 - 나머지는 단지 그것을 가능하게 하고 신뢰할 수 있고 구조화된 방식으로 발생하도록 보장하려고 시도합니다.

#### 4.4.1 Private 메시지

      명령: PRIVMSG
   매개변수: <receiver>{,<receiver>} <text to be sent>

PRIVMSG는 사용자 간 개인 메시지를 보내는 데 사용됩니다. <receiver>는 메시지 수신자의 닉네임입니다. <receiver>는 또한 쉼표로 구분된 이름이나 채널 목록일 수 있습니다.

<receiver> 매개변수는 호스트 마스크(#mask) 또는 서버 마스크($mask)일 수도 있습니다. 두 경우 모두 서버는 서버나 호스트가 마스크와 일치하는 사람들에게만 PRIVMSG를 보냅니다. 마스크에는 최소 1개의 "."가 있어야 하며 마지막 "." 이후에 와일드카드가 없어야 합니다. 이 요구사항은 사람들이 "#*" 또는 "$*"로 메시지를 보내는 것을 방지하기 위해 존재하며, 이는 모든 사용자에게 브로드캐스트될 것입니다. 경험상 이는 책임감 있고 적절하게 사용되는 것보다 남용되는 경우가 더 많습니다. 와일드카드는 '*'와 '?' 문자입니다. PRIVMSG 명령의 이 확장은 운영자만 사용할 수 있습니다.

숫자 응답:
           ERR_NORECIPIENT                 ERR_NOTEXTTOSEND
           ERR_CANNOTSENDTOCHAN            ERR_NOTOPLEVEL
           ERR_WILDTOPLEVEL                ERR_TOOMANYTARGETS
           ERR_NOSUCHNICK
           RPL_AWAY

예제:
:Angel PRIVMSG Wiz :Hello are you receiving this message ?
                                ; Angel에서 Wiz로의 메시지.

PRIVMSG Angel :yes I'm receiving it !receiving it !'u>(768u+1n) .br ;
                                Angel에게 보내는 메시지.

PRIVMSG jto@tolsun.oulu.fi :Hello !
                                ; tolsun.oulu.fi 서버에서 "jto"라는
                                사용자 이름을 가진 클라이언트에게
                                보내는 메시지.

PRIVMSG $*.fi :Server tolsun.oulu.fi rebooting.
                                ; *.fi와 일치하는 이름을 가진 서버의
                                모든 사람에게 보내는 메시지.

PRIVMSG #*.edu :NSFNet is undergoing work, expect interruptions
                                ; *.edu와 일치하는 호스트에서 온 모든
                                사용자에게 보내는 메시지.

#### 4.4.2 Notice

      명령: NOTICE
   매개변수: <nickname> <text>

NOTICE 메시지는 PRIVMSG와 유사하게 사용됩니다. NOTICE와 PRIVMSG의 차이점은 NOTICE 메시지에 대한 자동 응답을 절대 보내서는 안 된다는 것입니다. 이 규칙은 서버에도 적용됩니다 - NOTICE를 받으면 어떤 오류 응답도 클라이언트에게 다시 보내서는 안 됩니다. 이 규칙의 목적은 수신한 것에 대해 자동으로 무언가를 보내는 클라이언트가 다른 자동화 프로그램과 루프에 빠지는 것을 피하는 것입니다. 이는 일반적으로 자동화 프로그램(AI나 다른 대화형 프로그램이 그들의 행동을 제어하는 클라이언트)에 의해 사용되며, 다른 자동화 프로그램과 루프에 빠지지 않도록 항상 응답하는 것으로 보입니다.

응답과 예제에 대해서는 PRIVMSG를 참조하십시오.

### 4.5 사용자 기반 쿼리

사용자 쿼리는 주로 특정 사용자나 사용자 그룹에 대한 세부 정보를 찾는 것과 관련된 명령 그룹입니다. 이러한 명령 중 어느 것이든 와일드카드를 사용할 때, 일치하는 경우 '보이는' 사용자에 대한 정보만 반환합니다. 사용자의 가시성은 사용자의 모드와 둘 다 속한 공통 채널의 조합으로 결정됩니다.

#### 4.5.1 Who 쿼리

      명령: WHO
   매개변수: [<name> [<o>]]

WHO 메시지는 클라이언트가 제공한 <name> 매개변수와 '일치하는' 정보 목록을 생성하는 쿼리를 생성하는 데 사용됩니다. <name> 매개변수가 없는 경우, 모든 보이는 사용자(보이지 않음 사용자 모드(+i)가 아니고 요청 클라이언트와 공통 채널이 없는 사용자)가 나열됩니다. 같은 결과는 "0"이나 가능한 모든 항목과 일치하는 와일드카드를 <name>으로 사용하여 얻을 수 있습니다.

WHO로 전달된 <name>은 채널 <name>을 찾을 수 없는 경우 사용자의 호스트, 서버, 실제 이름 및 닉네임과 대조됩니다.

"o" 매개변수가 전달되면 제공된 이름 마스크에 따라 운영자만 반환됩니다.

숫자 응답:
           ERR_NOSUCHSERVER
           RPL_WHOREPLY                    RPL_ENDOFWHO

예제:
   WHO *.fi                        ; "*.fi"와 일치하는 모든 사용자 나열.

   WHO jto* o                      ; "jto*"와 일치하는 모든 사용자 중
                                   운영자인 경우 나열.

#### 4.5.2 Whois 쿼리

      명령: WHOIS
   매개변수: [<server>] <nickmask>[,<nickmask>[,...]]

이 메시지는 특정 사용자에 대한 정보를 쿼리하는 데 사용됩니다. 서버는 nickmask와 일치하는 각 사용자의 다양한 상태를 나타내는 여러 숫자 메시지로 이 메시지에 응답합니다(볼 수 있는 권한이 있는 경우). <nickmask>에 와일드카드가 없는 경우, 볼 수 있는 해당 닉에 대한 모든 정보가 제시됩니다. 쉼표(',')로 구분된 닉네임 목록이 제공될 수 있습니다.

후자 버전은 쿼리를 특정 서버로 보냅니다. 이는 해당 사용자가 얼마나 오래 유휴 상태였는지 알고 싶을 때 유용합니다. 로컬 서버(즉, 사용자가 직접 연결된 서버)만이 그 정보를 알고 있는 반면, 다른 모든 것은 전역적으로 알려져 있기 때문입니다.

숫자 응답:
           ERR_NOSUCHSERVER                ERR_NONICKNAMEGIVEN
           RPL_WHOISUSER                   RPL_WHOISCHANNELS
           RPL_WHOISCHANNELS               RPL_WHOISSERVER
           RPL_AWAY                        RPL_WHOISOPERATOR
           RPL_WHOISIDLE                   ERR_NOSUCHNICK
           RPL_ENDOFWHOIS

예제:
   WHOIS wiz                       ; 닉네임 WiZ에 대해 사용 가능한 사용자
                                   정보 반환

   WHOIS eff.org trillian          ; eff.org 서버에 trillian에 대한
                                   사용자 정보 요청

#### 4.5.3 Whowas

      명령: WHOWAS
   매개변수: <nickname> [<count> [<server>]]

Whowas는 더 이상 존재하지 않는 닉네임에 대한 정보를 요청합니다. 이는 닉네임 변경이나 사용자가 IRC를 떠난 경우 때문일 수 있습니다. 이 쿼리에 대한 응답으로 서버는 닉네임 기록을 검색하여 어휘적으로 동일한 닉네임을 찾습니다(와일드카드 매칭은 여기서 없음). 기록은 뒤로 검색되어 가장 최근 항목을 먼저 반환합니다. 여러 항목이 있는 경우, <count> 응답까지 반환됩니다(또는 <count> 매개변수가 주어지지 않은 경우 모든 항목). <count>로 0 이하의 숫자가 전달되면 전체 검색이 수행됩니다.

숫자 응답:
           ERR_NONICKNAMEGIVEN             ERR_WASNOSUCHNICK
           RPL_WHOWASUSER                  RPL_WHOISSERVER
           RPL_ENDOFWHOWAS

예제:
   WHOWAS Wiz                      ; 닉네임 "WiZ"에 대한 닉네임 기록의
                                   모든 정보 반환;

   WHOWAS Mermaid 9                ; "Mermaid"에 대한 닉네임 기록에서
                                   최대 9개의 가장 최근 항목 반환;

   WHOWAS Trillian 1 *.edu         ; "*.edu"와 일치하는 첫 번째 서버에서
                                   "Trillian"에 대한 가장 최근 기록 반환.

### 4.6 기타 메시지

이 카테고리의 메시지는 위의 어느 카테고리에도 속하지 않지만 여전히 프로토콜의 일부이며 필요합니다.

#### 4.6.1 Kill 메시지

      명령: KILL
   매개변수: <nickname> <comment>

KILL 메시지는 실제 연결이 있는 서버가 클라이언트-서버 연결을 닫게 하는 데 사용됩니다. KILL은 서버가 유효한 닉네임 목록에서 중복 항목을 발견했을 때 사용되며 두 항목을 모두 제거하는 데 사용됩니다. 또한 운영자도 사용할 수 있습니다.

자동 재연결 알고리즘이 있는 클라이언트는 연결 해제가 짧을 뿐이기 때문에 이 명령을 실질적으로 쓸모없게 만듭니다. 그러나 데이터 흐름을 중단시키고 많은 남용을 중단시키는 데 사용할 수 있습니다. 잠재적인 문제 지점을 '감시'하기 위해 다른 사람을 위해 생성된 KILL 메시지를 받기로 선택할 수 있습니다.

닉네임이 항상 전역적으로 고유해야 하는 영역에서, KILL 메시지는 '중복'이 감지될 때마다 전송됩니다(즉, 같은 닉네임으로 두 사용자를 등록하려는 시도). 둘 다 사라지고 1명만 다시 나타나기를 바라면서 전송됩니다.

주어진 댓글은 KILL에 대한 실제 이유를 반영해야 합니다. 서버에서 생성된 KILL의 경우 일반적으로 충돌하는 두 닉네임의 출처에 대한 세부 정보로 구성됩니다. 사용자의 경우 다른 사람들이 보기에 적절한 이유를 제공하는 것은 그들에게 달려 있습니다. KILL을 생성한 사람의 신원을 숨기기 위해 가짜 KILL이 생성되는 것을 방지/저지하기 위해, 댓글은 통과하는 각 서버가 이름을 경로에 추가하여 업데이트하는 'kill-경로'도 보여줍니다.

숫자 응답:
           ERR_NOPRIVILEGES                ERR_NEEDMOREPARAMS
           ERR_NOSUCHNICK                  ERR_CANTKILLSERVER


   KILL David (csd.bu.edu <- tolsun.oulu.fi)
                                   ; csd.bu.edu와 tolson.oulu.fi 사이의
                                   닉네임 충돌


   참고:
   KILL 메시지로 다른 사용자를 죽일 수 있는 권한은 운영자에게만 허용되는 것이 권장됩니다. 이상적인 세상에서는 운영자조차도 이것을 할 필요가 없고 서버가 처리하도록 맡겨질 것입니다.

#### 4.6.2 Ping 메시지

      명령: PING
   매개변수: <server1> [<server2>]

PING 메시지는 연결의 다른 쪽 끝에 있는 활성 클라이언트의 존재를 테스트하는 데 사용됩니다. 연결에서 다른 활동이 감지되지 않으면 정기적인 간격으로 PING 메시지가 전송됩니다. 연결이 설정된 시간 내에 PING 명령에 응답하지 않으면 해당 연결이 종료됩니다.

PING 메시지를 받는 모든 클라이언트는 자신이 여전히 존재하고 살아있음을 나타내기 위해 가능한 한 빨리 <server1>(PING 메시지를 보낸 서버)에 적절한 PONG 메시지로 응답해야 합니다. 서버는 PING 명령에 응답해서는 안 되며, 연결이 살아있다는 것을 나타내기 위해 연결의 다른 쪽 끝에서 오는 PING에 의존해야 합니다. <server2> 매개변수가 지정된 경우, PING 메시지는 그곳으로 전달됩니다.

숫자 응답:
           ERR_NOORIGIN                    ERR_NOSUCHSERVER

예제:
   PING tolsun.oulu.fi             ; 서버가 다른 서버에 여전히 살아있음을
                                   나타내기 위해 PING 메시지를 보냄.

   PING WiZ                        ; 닉네임 WiZ로 보내지는 PING 메시지

#### 4.6.3 Pong 메시지

      명령: PONG
   매개변수: <daemon> [<daemon2>]

PONG 메시지는 PING 메시지에 대한 응답입니다. 매개변수 <daemon2>가 주어진 경우 이 메시지는 주어진 데몬으로 전달되어야 합니다. <daemon> 매개변수는 PING 메시지에 응답하고 이 메시지를 생성한 데몬의 이름입니다.

숫자 응답:
           ERR_NOORIGIN                    ERR_NOSUCHSERVER

예제:
   PONG csd.bu.edu tolsun.oulu.fi  ; csd.bu.edu에서 tolsun.oulu.fi로의
                                   PONG 메시지

#### 4.6.4 Error

      명령: ERROR
   매개변수: <error message>

ERROR 명령은 서버가 운영자에게 심각하거나 치명적인 오류를 보고할 때 사용됩니다. 또한 한 서버에서 다른 서버로 보낼 수 있지만 일반적인 알 수 없는 클라이언트로부터는 수락되어서는 안 됩니다.

ERROR 메시지는 서버-서버 링크에서 발생하는 오류를 보고하는 데만 사용됩니다. ERROR 메시지는 다른 쪽 끝에 있는 서버로 보내지며(이는 이를 모든 연결된 운영자에게 보냅니다) 그리고 현재 연결된 모든 운영자에게 보내집니다. 서버가 서버로부터 받은 ERROR 메시지를 다른 서버로 전달해서는 안 됩니다.

서버가 받은 ERROR 메시지를 운영자에게 보낼 때, 클라이언트가 오류에 대해 책임이 없음을 나타내기 위해 NOTICE 메시지 안에 메시지를 캡슐화해야 합니다.

숫자:
           없음.

예제:
   ERROR :Server *.fi already exists; 이 오류를 일으킨 다른 서버에 대한
                                   ERROR 메시지.

   NOTICE WiZ :ERROR from csd.bu.edu -- Server *.fi already exists
                                   ; 위와 동일한 ERROR 메시지지만 다른
                                   서버의 사용자 WiZ에게 보내짐.

### 5. OPTIONALS

이 섹션은 선택적 메시지를 설명합니다. 이들은 여기서 설명하는 프로토콜의 작동하는 서버 구현에 필수적이지 않습니다. 옵션이 없는 경우, 오류 응답 메시지를 생성하거나 알 수 없는 명령 오류를 생성해야 합니다. 메시지가 다른 서버가 응답할 대상인 경우 전달되어야 합니다(기본적인 구문 분석 필요). 이에 할당된 숫자는 아래 메시지와 함께 나열되어 있습니다.

#### 5.1 Away

      명령: AWAY
   매개변수: [message]

AWAY 메시지를 통해 클라이언트는 자신에게 전달된(채널이 아닌) PRIVMSG 명령에 대한 자동 응답 문자열을 설정할 수 있습니다. 자동 응답은 PRIVMSG 명령을 보내는 클라이언트에게 서버가 보냅니다. 응답하는 서버는 보내는 클라이언트가 연결된 서버만입니다.

AWAY 메시지는 하나의 매개변수(AWAY 메시지 설정)와 함께 사용하거나 매개변수 없이(AWAY 메시지 제거) 사용할 수 있습니다.

숫자 응답:
           RPL_UNAWAY                      RPL_NOWAWAY

예제:
   AWAY :Gone to lunch.  Back in 5 ; AWAY 메시지를 "Gone to lunch.
                                   Back in 5"로 설정.

   :WiZ AWAY                       ; WiZ를 더 이상 away로 표시하지 않음.

#### 5.2 Rehash 메시지

      명령: REHASH
   매개변수: 없음

REHASH 메시지는 운영자가 서버의 설정 파일을 다시 읽고 처리하도록 강제하는 데 사용할 수 있습니다.

숫자 응답:
        RPL_REHASHING                   ERR_NOPRIVILEGES

예제:
REHASH                          ; 설정 파일을 다시 읽도록 서버에 요청하는
                                운영자 상태의 클라이언트의 메시지.

#### 5.3 Restart 메시지

      명령: RESTART
   매개변수: 없음

RESTART 메시지는 운영자만 사용하여 서버를 재시작하도록 강제할 수 있습니다. 이 메시지는 임의의 사람들이 서버에 운영자로 연결하여 이 명령을 실행하도록 허용하는 것이 위험으로 간주될 수 있기 때문에 선택적입니다. RESTART 명령은 보내는 클라이언트가 연결된 서버에서 항상 완전히 처리되어야 하며 다른 연결된 서버로 전달되어서는 안 됩니다.

숫자 응답:
           ERR_NOPRIVILEGES

예제:
   RESTART                         ; 매개변수 필요 없음.

#### 5.4 Summon 메시지

      명령: SUMMON
   매개변수: <user> [<server>]

SUMMON 명령은 IRC 서버를 실행하는 호스트에 있는 사용자에게 IRC에 참여해달라는 메시지를 보내는 데 사용할 수 있습니다. 이 메시지는 대상 서버가 (a) SUMMON이 활성화되어 있고, (b) 사용자가 로그인되어 있고 (c) 서버 프로세스가 사용자의 tty(또는 유사한 것)에 쓸 수 있는 경우에만 보내집니다.

<server> 매개변수가 주어지지 않으면 클라이언트가 연결된 서버를 대상으로 <user>를 소환하려고 시도합니다.

서버에서 SUMMON이 활성화되어 있지 않은 경우, ERR_SUMMONDISABLED 숫자를 반환하고 SUMMON 메시지를 계속 전달해야 합니다.

숫자 응답:
           ERR_NORECIPIENT                 ERR_FILEERROR
           ERR_NOLOGIN                     ERR_NOSUCHSERVER
           RPL_SUMMONING

예제:
   SUMMON jto                      ; 서버 호스트의 사용자 jto 소환

   SUMMON jto tolsun.oulu.fi       ; "tolsun.oulu.fi"라는 서버가 실행 중인
                                   호스트의 사용자 jto 소환.

#### 5.5 Users

      명령: USERS
   매개변수: [<server>]

USERS 명령은 who(1), rusers(1) 및 finger(1)와 유사한 형식으로 서버에 로그인한 사용자 목록을 반환합니다. 일부 사람들은 보안 관련 이유로 자신의 서버에서 이 명령을 비활성화할 수 있습니다. 비활성화된 경우, 이를 나타내기 위해 올바른 숫자를 반환해야 합니다.

숫자 응답:
           ERR_NOSUCHSERVER                ERR_FILEERROR
           RPL_USERSSTART                  RPL_USERS
           RPL_NOUSERS                     RPL_ENDOFUSERS
           ERR_USERSDISABLED

비활성화 응답:
           ERR_USERSDISABLED

예제:
USERS eff.org                   ; 서버 eff.org에 로그인한 사용자 목록 요청

:John USERS tolsun.oulu.fi      ; 서버 tolsun.oulu.fi에 로그인한 사용자
                                목록에 대한 John의 요청

#### 5.6 Operwall 메시지

      명령: WALLOPS
   매개변수: 현재 온라인인 모든 운영자에게 보낼 텍스트

현재 온라인인 모든 운영자에게 메시지를 보냅니다. 사용자 명령으로 WALLOPS를 구현한 후, 많은 사람들에게 메시지를 보내는 수단으로 자주 그리고 일반적으로 남용되는 것이 발견되었습니다(WALL과 매우 유사함). 이로 인해 현재 WALLOPS 구현을 예시로 사용하여 발신자로서 서버만을 허용하고 인식하는 것이 권장됩니다.

숫자 응답:
           ERR_NEEDMOREPARAMS

예제:
   :csd.bu.edu WALLOPS :Connect '*.uiuc.edu 6667' from Joshua; Joshua로부터
                                   받아 처리한 CONNECT 메시지를 알리는
                                   csd.bu.edu의 WALLOPS 메시지

#### 5.7 Userhost 메시지

      명령: USERHOST
   매개변수: <nickname>{<space><nickname>}

USERHOST 명령은 공백 문자로 구분된 최대 5개의 닉네임 목록을 받아 찾은 각 닉네임에 대한 정보 목록을 반환합니다. 반환된 목록의 각 응답은 공백으로 구분됩니다.

숫자 응답:
           RPL_USERHOST                    ERR_NEEDMOREPARAMS

예제:
   USERHOST Wiz Michael Marty p    ; 닉네임 "Wiz", "Michael", "Marty",
                                   "p"에 대한 정보 USERHOST 요청

#### 5.8 Ison 메시지

      명령: ISON
   매개변수: <nickname>{<space><nickname>}

ISON 명령은 주어진 닉네임이 현재 IRC에 있는지에 대한 빠르고 효율적인 응답을 얻기 위해 구현되었습니다. ISON은 하나(1)의 매개변수만 받습니다: 공백으로 구분된 닉네임 목록. 목록에서 현재 존재하는 각 닉네임에 대해, 서버는 그것을 응답 문자열에 추가합니다. 따라서 응답 문자열은 비어 있을 수 있고(주어진 닉네임이 하나도 없음), 매개변수 문자열의 정확한 복사본(모두 있음) 또는 주어진 닉네임 세트의 다른 하위 집합일 수 있습니다. 확인할 수 있는 닉네임 수에 대한 유일한 제한은 서버가 512자에 맞도록 잘라내지 않도록 전체 길이여야 합니다.

ISON은 명령을 보내는 클라이언트의 로컬 서버에서만 처리되며, 따라서 추가 처리를 위해 다른 서버로 전달되지 않습니다.

숫자 응답:
           RPL_ISON                ERR_NEEDMOREPARAMS

예제:
   ISON phone trillian WiZ jarlek Avalon Angel Monstah
                                   ; 7개의 닉네임에 대한 ISON 요청 예시.

### 6. REPLIES

다음은 위에서 주어진 명령에 대한 응답으로 생성되는 숫자 응답 목록입니다. 각 숫자는 번호, 이름 및 응답 문자열과 함께 제공됩니다.

#### 6.1 오류 응답

        401     ERR_NOSUCHNICK
                        "<nickname> :No such nick/channel"

                - 명령에 제공된 닉네임 매개변수가 현재 사용되지 않음을
                  나타내는 데 사용됩니다.

        402     ERR_NOSUCHSERVER
                        "<server name> :No such server"

                - 주어진 서버 이름이 현재 존재하지 않음을 나타내는 데
                  사용됩니다.

        403     ERR_NOSUCHCHANNEL
                        "<channel name> :No such channel"

                - 주어진 채널 이름이 유효하지 않음을 나타내는 데
                  사용됩니다.

        404     ERR_CANNOTSENDTOCHAN
                        "<channel name> :Cannot send to channel"

                - (a) 모드 +n인 채널에 있지 않거나 (b) 모드 +m이
                  설정된 채널에서 채널 운영자(또는 모드 +v)가 아닌
                  사용자가 해당 채널에 PRIVMSG 메시지를 보내려고
                  할 때 보내집니다.

        405     ERR_TOOMANYCHANNELS
                        "<channel name> :You have joined too many \
                         channels"
                - 사용자가 허용된 최대 채널 수에 가입했을 때 다른
                  채널에 가입하려고 할 때 보내집니다.

        406     ERR_WASNOSUCHNICK
                        "<nickname> :There was no such nickname"

                - 해당 닉네임에 대한 기록 정보가 없음을 나타내기 위해
                  WHOWAS가 반환합니다.

        407     ERR_TOOMANYTARGETS
                        "<target> :Duplicate recipients. No message \
                         delivered"

                - 클라이언트가 user@host 대상 형식을 사용하여
                  PRIVMSG/NOTICE를 보내려고 할 때 여러 발생이 있는
                  user@host에 대해 반환됩니다.

        409     ERR_NOORIGIN
                        ":No origin specified"

                - 유효한 접두사 없이도 작동해야 하는 PING 또는 PONG
                  메시지에서 필수적인 발신자 매개변수가 누락되었을 때.

        411     ERR_NORECIPIENT
                        ":No recipient given (<command>)"
        412     ERR_NOTEXTTOSEND
                        ":No text to send"
        413     ERR_NOTOPLEVEL
                        "<mask> :No toplevel domain specified"
        414     ERR_WILDTOPLEVEL
                        "<mask> :Wildcard in toplevel domain"

                - 412 - 414는 어떤 이유로 메시지가 전달되지 않았음을
                  나타내기 위해 PRIVMSG에 의해 반환됩니다.
                  ERR_NOTOPLEVEL과 ERR_WILDTOPLEVEL은 "PRIVMSG $<server>"
                  또는 "PRIVMSG #<host>"의 잘못된 사용을 시도할 때
                  반환되는 오류입니다.

        421     ERR_UNKNOWNCOMMAND
                        "<command> :Unknown command"

                - 등록된 클라이언트에게 서버가 모르는 명령을 보냈음을
                  나타내기 위해 반환됩니다.

        422     ERR_NOMOTD
                        ":MOTD File is missing"

                - 서버의 MOTD 파일을 서버가 열 수 없을 때.

        423     ERR_NOADMININFO
                        "<server> :No administrative info available"

                - 적절한 정보를 찾는 데 오류가 있을 때 ADMIN 메시지에
                  대한 응답으로 서버가 반환합니다.

        424     ERR_FILEERROR
                ":File error doing <file op> on <file>"
                - 메시지 처리 중 파일 작업 실패를 보고하는 데 사용되는
                  일반적인 오류 메시지입니다.

        431     ERR_NONICKNAMEGIVEN
                        ":No nickname given"

                - 명령에 필요한 닉네임 매개변수가 없을 때 반환됩니다.

        432     ERR_ERRONEUSNICKNAME
                        "<nick> :Erroneus nickname"

                - 정의된 집합에 속하지 않는 문자를 포함하는 NICK
                  메시지를 받은 후 반환됩니다. 유효한 닉네임에 대한
                  자세한 내용은 section x.x.x를 참조하십시오.

        433     ERR_NICKNAMEINUSE
                        "<nick> :Nickname is already in use"

                - 현재 존재하는 닉네임으로 변경하려는 시도로 인한
                  NICK 메시지를 처리할 때 반환됩니다.

        436     ERR_NICKCOLLISION
                        "<nick> :Nickname collision KILL"

                - 서버가 클라이언트에게 다른 서버에 의해 이미 존재하는
                  NICK의 등록을 감지했을 때 반환됩니다.

        441     ERR_USERNOTINCHANNEL
                        "<nick> <channel> :They aren't on that channel"

                - 명령의 대상 사용자가 주어진 채널에 없음을 나타내기
                  위해 서버가 반환합니다.

        442     ERR_NOTONCHANNEL
                        "<channel> :You're not on that channel"

                - 클라이언트가 자신이 구성원이 아닌 채널에 영향을 미치는
                  명령을 수행하려고 할 때마다 서버가 반환합니다.

        443     ERR_USERONCHANNEL
                        "<user> <channel> :is already on channel"

                - 클라이언트가 이미 채널에 있는 사용자를 초대하려고
                  할 때 반환됩니다.

        444     ERR_NOLOGIN
                        "<user> :User not logged in"

                - SUMMON 명령 후 사용자가 로그인하지 않아 수행할 수
                  없을 때 summon이 반환합니다.

        445     ERR_SUMMONDISABLED
                        ":SUMMON has been disabled"

                - SUMMON 명령에 대한 응답으로 반환됩니다. 이를 구현하지
                  않는 모든 서버가 반환해야 합니다.

        446     ERR_USERSDISABLED
                        ":USERS has been disabled"

                - USERS 명령에 대한 응답으로 반환됩니다. 이를 구현하지
                  않는 모든 서버가 반환해야 합니다.

        451     ERR_NOTREGISTERED
                        ":You have not registered"

                - 서버가 클라이언트를 자세히 구문 분석하도록 허용하기
                  전에 클라이언트가 등록되어야 함을 나타내기 위해
                  서버가 반환합니다.

        461     ERR_NEEDMOREPARAMS
                        "<command> :Not enough parameters"

                - 클라이언트가 충분한 매개변수를 제공하지 않았음을
                  나타내기 위해 많은 명령이 서버에 의해 반환됩니다.

        462     ERR_ALREADYREGISTRED
                        ":You may not reregister"

                - 등록된 세부 정보(예: 두 번째 USER 메시지의 비밀번호나
                  사용자 세부 정보)를 변경하려는 모든 링크에 대해
                  서버가 반환합니다.

        463     ERR_NOPERMFORHOST
                        ":Your host isn't among the privileged"

                - 시도된 연결이 허용되도록 설정되지 않은 호스트에서
                  서버에 등록하려는 클라이언트에 반환됩니다.

        464     ERR_PASSWDMISMATCH
                        ":Password incorrect"

                - 비밀번호가 필요하고 제공되지 않았거나 잘못된 연결
                  등록 시도가 실패했음을 나타내기 위해 반환됩니다.

        465     ERR_YOUREBANNEDCREEP
                        ":You are banned from this server"

                - 명시적으로 연결을 거부하도록 설정된 서버에 연결하고
                  등록하려는 시도 후에 반환됩니다.

        467     ERR_KEYSET
                        "<channel> :Channel key already set"
        471     ERR_CHANNELISFULL
                        "<channel> :Cannot join channel (+l)"
        472     ERR_UNKNOWNMODE
                        "<char> :is unknown mode char to me"
        473     ERR_INVITEONLYCHAN
                        "<channel> :Cannot join channel (+i)"
        474     ERR_BANNEDFROMCHAN
                        "<channel> :Cannot join channel (+b)"
        475     ERR_BADCHANNELKEY
                        "<channel> :Cannot join channel (+k)"
        481     ERR_NOPRIVILEGES
                        ":Permission Denied- You're not an IRC operator"

                - 운영에 운영자 권한이 필요한 모든 명령은 시도가
                  실패했음을 나타내기 위해 이 오류를 반환해야 합니다.

        482     ERR_CHANOPRIVSNEEDED
                        "<channel> :You're not channel operator"

                - MODE 메시지와 같은 'chanop' 권한이 필요한 모든 명령은
                  시도를 하는 클라이언트가 지정된 채널의 채널 운영자가
                  아닌 경우 이 오류를 반환해야 합니다.

        483     ERR_CANTKILLSERVER
                        ":You cant kill a server!"

                - 서버에 대한 KILL 명령 사용 시도는 거부되어야 하며
                  이 오류가 클라이언트에 직접 반환되어야 합니다.

        491     ERR_NOOPERHOST
                        ":No O-lines for your host"

                - 클라이언트가 OPER 메시지를 보내고 서버가 클라이언트의
                  호스트에서 운영자로서의 연결을 허용하도록 구성되지
                  않은 경우 이 오류가 반환되어야 합니다.

        501     ERR_UMODEUNKNOWNFLAG
                        ":Unknown MODE flag"

                - 닉네임 매개변수와 함께 MODE 메시지가 전송되었고
                  전송된 모드 플래그가 인식되지 않았음을 나타내기 위해
                  서버가 반환합니다.

        502     ERR_USERSDONTMATCH
                        ":Cant change mode for other users"

                - 자신 이외의 사용자에 대한 사용자 모드를 보거나
                  변경하려는 모든 사용자에게 보내는 오류입니다.

#### 6.2 명령 응답

        300     RPL_NONE
                        더미 응답 번호. 사용되지 않음.

        302     RPL_USERHOST
                        ":[<reply>{<space><reply>}]"

                - USERHOST가 쿼리 목록에 대한 응답을 나열하는 데
                  사용하는 응답 형식. 응답 문자열은 다음과 같이 구성됨:

                  <reply> ::= <nick>['*'] '=' <'+'|'-'><hostname>

                  '*'는 클라이언트가 운영자로 등록되었는지를 나타냅니다.
                  '-' 또는 '+' 문자는 각각 클라이언트가 AWAY 메시지를
                  설정했는지 여부를 나타냅니다.

        303     RPL_ISON
                        ":[<nick> {<space><nick>}]"

                - ISON이 쿼리 목록에 대한 응답을 나열하는 데 사용하는
                  응답 형식.

        301     RPL_AWAY
                        "<nick> :<away message>"
        305     RPL_UNAWAY
                        ":You are no longer marked as being away"
        306     RPL_NOWAWAY
                        ":You have been marked as being away"

                - 이 응답들은 AWAY 명령과 함께 사용됩니다(허용된 경우).
                  RPL_AWAY는 away 상태인 클라이언트에게 PRIVMSG를 보내는
                  모든 클라이언트에게 전송됩니다. RPL_AWAY는 클라이언트가
                  연결된 서버에서만 전송됩니다. RPL_UNAWAY와 RPL_NOWAWAY
                  응답은 클라이언트가 AWAY 메시지를 제거하고 설정할 때
                  전송됩니다.

        311     RPL_WHOISUSER
                        "<nick> <user> <host> * :<real name>"
        312     RPL_WHOISSERVER
                        "<nick> <server> :<server info>"
        313     RPL_WHOISOPERATOR
                        "<nick> :is an IRC operator"
        317     RPL_WHOISIDLE
                        "<nick> <integer> :seconds idle"
        318     RPL_ENDOFWHOIS
                        "<nick> :End of /WHOIS list"
        319     RPL_WHOISCHANNELS
                        "<nick> :{[@|+]<channel><space>}"

                - 응답 311 - 313, 317 - 319는 모두 WHOIS 메시지에
                  대한 응답으로 생성됩니다. 충분한 매개변수가 있다면,
                  응답하는 서버는 (쿼리 닉이 발견되면) 위의 숫자로
                  응답을 작성하거나 오류 응답을 반환해야 합니다.
                  RPL_WHOISUSER의 '*'는 와일드카드가 아닌 문자
                  그대로입니다. 각 응답 세트에서 RPL_WHOISCHANNELS만
                  (긴 채널 이름 목록의 경우) 한 번 이상 나타날 수
                  있습니다. 채널 이름 옆의 '@'와 '+' 문자는 클라이언트가
                  채널 운영자인지 또는 중재된 채널에서 발언 권한을
                  부여받았는지를 나타냅니다. RPL_ENDOFWHOIS 응답은
                  WHOIS 메시지 처리의 끝을 표시하는 데 사용됩니다.

        314     RPL_WHOWASUSER
                        "<nick> <user> <host> * :<real name>"
        369     RPL_ENDOFWHOWAS
                        "<nick> :End of WHOWAS"

                - WHOWAS 메시지에 응답할 때, 서버는 제시된 목록의 각
                  닉네임에 대해 RPL_WHOWASUSER, RPL_WHOISSERVER 또는
                  ERR_WASNOSUCHNICK을 사용해야 합니다. 모든 응답 배치의
                  끝에는 RPL_ENDOFWHOWAS가 있어야 합니다(응답이 하나뿐이고
                  그것이 오류인 경우에도).

        321     RPL_LISTSTART
                        "Channel :Users  Name"
        322     RPL_LIST
                        "<channel> <# visible> :<topic>"
        323     RPL_LISTEND
                        ":End of /LIST"

                - RPL_LISTSTART, RPL_LIST, RPL_LISTEND 응답은 LIST
                  명령에 대한 서버의 응답의 시작, 실제 데이터가 있는
                  응답 및 끝을 표시합니다. 반환할 수 있는 채널이 없는
                  경우 시작과 끝 응답만 보내야 합니다.

        324     RPL_CHANNELMODEIS
                        "<channel> <mode> <mode params>"

        331     RPL_NOTOPIC
                        "<channel> :No topic is set"
        332     RPL_TOPIC
                        "<channel> :<topic>"

                - 채널 주제를 결정하기 위해 TOPIC 메시지를 보낼 때,
                  두 가지 응답 중 하나가 전송됩니다. 주제가 설정되어
                  있으면 RPL_TOPIC이 반환되고, 그렇지 않으면
                  RPL_NOTOPIC이 반환됩니다.

        341     RPL_INVITING
                        "<channel> <nick>"

                - 시도된 INVITE 메시지가 성공적이었고 최종 클라이언트에게
                  전달되고 있음을 나타내기 위해 서버가 반환합니다.

        342     RPL_SUMMONING
                        "<user> :Summoning user to IRC"

                - SUMMON 메시지에 응답하여 해당 사용자를 소환하고
                  있음을 나타내기 위해 서버가 반환합니다.

        351     RPL_VERSION
                        "<version>.<debuglevel> <server> :<comments>"

                - 서버의 버전 세부 정보를 보여주는 서버의 응답.
                  <version>은 (모든 패치레벨 수정을 포함한) 사용 중인
                  소프트웨어의 버전이고 <debuglevel>은 서버가 "디버그
                  모드"로 실행 중인지를 나타내는 데 사용됩니다.

                  "comments" 필드에는 버전에 대한 모든 설명이나 추가
                  버전 세부 정보가 포함될 수 있습니다.

        352     RPL_WHOREPLY
                        "<channel> <user> <host> <server> <nick> \
                         <H|G>[*][@|+] :<hopcount> <real name>"
        315     RPL_ENDOFWHO
                        "<name> :End of /WHO list"

                - RPL_WHOREPLY와 RPL_ENDOFWHO 쌍은 WHO 메시지에
                  응답하는 데 사용됩니다. RPL_WHOREPLY는 WHO 쿼리와
                  적절히 일치하는 경우에만 전송됩니다. WHO 메시지와
                  함께 매개변수 목록이 제공된 경우, <name>이 해당
                  항목인 각 목록 항목을 처리한 후 RPL_ENDOFWHO를
                  보내야 합니다.

        353     RPL_NAMREPLY
                        "<channel> :[[@|+]<nick> [[@|+]<nick> [...]]]"
        366     RPL_ENDOFNAMES
                        "<channel> :End of /NAMES list"

                - NAMES 메시지에 응답하기 위해, RPL_NAMREPLY와
                  RPL_ENDOFNAMES로 구성된 응답 쌍이 서버에서
                  클라이언트로 다시 전송됩니다. 쿼리에서와 같은 채널이
                  없는 경우 RPL_ENDOFNAMES만 반환됩니다. 이에 대한
                  예외는 매개변수 없이 NAMES 메시지가 전송되고 모든
                  보이는 채널과 내용이 RPL_NAMEREPLY 메시지 시리즈로
                  다시 전송되며 끝을 표시하기 위한 RPL_ENDOFNAMES가
                  있는 경우입니다.

        364     RPL_LINKS
                        "<mask> <server> :<hopcount> <server info>"
        365     RPL_ENDOFLINKS
                        "<mask> :End of /LINKS list"

                - LINKS 메시지에 응답할 때, 서버는 RPL_LINKS 숫자를
                  사용하여 응답을 다시 보내고 RPL_ENDOFLINKS를 사용하여
                  목록의 끝을 표시해야 합니다.

        367     RPL_BANLIST
                        "<channel> <banid>"
        368     RPL_ENDOFBANLIST
                        "<channel> :End of channel ban list"

                - 주어진 채널의 활성 'ban'을 나열할 때, 서버는
                  RPL_BANLIST와 RPL_ENDOFBANLIST 메시지를 사용하여
                  목록을 다시 보내야 합니다. 각 활성 banid에 대해
                  별도의 RPL_BANLIST가 전송됩니다. banid가 나열된 후
                  (또는 존재하지 않는 경우) RPL_ENDOFBANLIST가
                  전송되어야 합니다.

        371     RPL_INFO
                        ":<string>"
        374     RPL_ENDOFINFO
                        ":End of /INFO list"

                - INFO 메시지에 응답하는 서버는 모든 'info'를
                  RPL_INFO 메시지 시리즈로 보내고 응답의 끝을 나타내기
                  위해 RPL_ENDOFINFO 응답을 보내야 합니다.

        375     RPL_MOTDSTART
                        ":- <server> Message of the day - "
        372     RPL_MOTD
                        ":- <text>"
        376     RPL_ENDOFMOTD
                        ":End of /MOTD command"

                - MOTD 메시지에 응답하고 MOTD 파일이 발견되면, 파일은
                  각 줄이 80자를 넘지 않게 RPL_MOTD 형식 응답을
                  사용하여 줄별로 표시됩니다. 이들은 RPL_MOTDSTART
                  (RPL_MOTD 이전)와 RPL_ENDOFMOTD (이후)로 둘러싸여야
                  합니다.

        381     RPL_YOUREOPER
                        ":You are now an IRC operator"

                - RPL_YOUREOPER는 OPER 메시지를 방금 성공적으로
                  발행하고 운영자 상태를 얻은 클라이언트에게 다시
                  보내집니다.

        382     RPL_REHASHING
                        "<config file> :Rehashing"

                - REHASH 옵션이 사용되고 운영자가 REHASH 메시지를
                  보내면, RPL_REHASHING이 운영자에게 다시 보내집니다.

        391     RPL_TIME
                        "<server> :<string showing server's local time>"

                - TIME 메시지에 응답할 때, 서버는 위의 RPL_TIME
                  형식을 사용하여 응답을 보내야 합니다. 시간을 보여주는
                  문자열은 올바른 날짜와 시간만 포함하면 됩니다.
                  시간 문자열에 대한 추가 요구 사항은 없습니다.

        392     RPL_USERSSTART
                        ":UserID   Terminal  Host"
        393     RPL_USERS
                        ":%-8s %-9s %-8s"
        394     RPL_ENDOFUSERS
                        ":End of users"
        395     RPL_NOUSERS
                        ":Nobody logged in"

                - USERS 메시지가 서버에 의해 처리되는 경우,
                  RPL_USERSTART, RPL_USERS, RPL_ENDOFUSERS 및
                  RPL_NOUSERS 응답이 사용됩니다. RPL_USERSSTART가
                  먼저 전송되어야 하며, 그 다음에 RPL_USERS 시퀀스나
                  단일 RPL_NOUSER가 옵니다. 이후에 RPL_ENDOFUSERS가
                  따릅니다.

        200     RPL_TRACELINK
                        "Link <version & debug level> <destination> \
                         <next server>"
        201     RPL_TRACECONNECTING
                        "Try. <class> <server>"
        202     RPL_TRACEHANDSHAKE
                        "H.S. <class> <server>"
        203     RPL_TRACEUNKNOWN
                        "???? <class> [<client IP address in dot form>]"
        204     RPL_TRACEOPERATOR
                        "Oper <class> <nick>"
        205     RPL_TRACEUSER
                        "User <class> <nick>"
        206     RPL_TRACESERVER
                        "Serv <class> <int>S <int>C <server> \
                         <nick!user|*!*>@<host|server>"
        208     RPL_TRACENEWTYPE
                        "<newtype> 0 <client name>"
        261     RPL_TRACELOG
                        "File <logfile> <debug level>"

                - RPL_TRACE*는 모두 TRACE 메시지에 대한 응답으로
                  서버에서 반환됩니다. 반환되는 수는 TRACE 메시지와
                  운영자가 보냈는지 여부에 따라 달라집니다. 어느 것이
                  먼저 발생하는지에 대한 미리 정의된 순서는 없습니다.
                  RPL_TRACEUNKNOWN, RPL_TRACECONNECTING 및
                  RPL_TRACEHANDSHAKE 응답은 모두 완전히 설정되지
                  않은 연결에 사용되며, 이는 알 수 없거나, 여전히
                  연결을 시도 중이거나, '서버 핸드셰이크' 과정을
                  완료하는 중입니다. RPL_TRACELINK는 TRACE 메시지를
                  처리하고 다른 서버로 전달해야 하는 모든 서버에서
                  전송됩니다. IRC 네트워크를 통과하는 TRACE 명령에
                  대한 응답으로 보내는 RPL_TRACELINK 목록은 해당
                  경로를 따라 서버들 자체의 실제 연결성을 반영해야
                  합니다. RPL_TRACENEWTYPE은 다른 카테고리에 맞지
                  않지만 어쨌든 표시되는 모든 연결에 사용됩니다.

        211     RPL_STATSLINKINFO
                        "<linkname> <sendq> <sent messages> \
                         <sent bytes> <received messages> \
                         <received bytes> <time open>"
        212     RPL_STATSCOMMANDS
                        "<command> <count>"
        213     RPL_STATSCLINE
                        "C <host> * <name> <port> <class>"
        214     RPL_STATSNLINE
                        "N <host> * <name> <port> <class>"
        215     RPL_STATSILINE
                        "I <host> * <host> <port> <class>"
        216     RPL_STATSKLINE
                        "K <host> * <username> <port> <class>"
        218     RPL_STATSYLINE
                        "Y <class> <ping frequency> <connect \
                         frequency> <max sendq>"
        219     RPL_ENDOFSTATS
                        "<stats letter> :End of /STATS report"
        241     RPL_STATSLLINE
                        "L <hostmask> * <servername> <maxdepth>"
        242     RPL_STATSUPTIME
                        ":Server Up %d days %d:%02d:%02d"
        243     RPL_STATSOLINE
                        "O <hostmask> * <name>"
        244     RPL_STATSHLINE
                        "H <hostmask> * <servername>"

        221     RPL_UMODEIS
                        "<user mode string>"

                        - 클라이언트 자신의 모드에 대한 쿼리에 응답하기
                          위해 RPL_UMODEIS가 다시 전송됩니다.

        251     RPL_LUSERCLIENT
                        ":There are <integer> users and <integer> \
                         invisible on <integer> servers"
        252     RPL_LUSEROP
                        "<integer> :operator(s) online"
        253     RPL_LUSERUNKNOWN
                        "<integer> :unknown connection(s)"
        254     RPL_LUSERCHANNELS
                        "<integer> :channels formed"
        255     RPL_LUSERME
                        ":I have <integer> clients and <integer> \
                          servers"

                        - LUSERS 메시지를 처리할 때, 서버는 RPL_LUSERCLIENT,
                          RPL_LUSEROP, RPL_USERUNKNOWN,
                          RPL_LUSERCHANNELS 및 RPL_LUSERME 응답 세트를
                          보냅니다. 응답할 때, 서버는 RPL_LUSERCLIENT와
                          RPL_LUSERME를 다시 보내야 합니다. 다른 응답은
                          0이 아닌 수가 발견된 경우에만 다시 보내집니다.

        256     RPL_ADMINME
                        "<server> :Administrative info"
        257     RPL_ADMINLOC1
                        ":<admin info>"
        258     RPL_ADMINLOC2
                        ":<admin info>"
        259     RPL_ADMINEMAIL
                        ":<admin info>"

                        - ADMIN 메시지에 응답할 때, 서버는 RLP_ADMINME부터
                          RPL_ADMINEMAIL까지의 응답을 사용하고 각각에
                          텍스트 메시지를 제공해야 합니다. RPL_ADMINLOC1에는
                          서버가 위치한 도시, 주 및 국가에 대한 설명이
                          예상되며, 그 다음에는 대학 및 부서 세부 정보
                          (RPL_ADMINLOC2) 및 마지막으로 서버의 관리
                          연락처(여기에는 이메일 주소가 필요)가
                          RPL_ADMINEMAIL에 포함됩니다.

### 6.3 예약된 숫자

이러한 숫자는 다음 범주 중 하나에 속하기 때문에 위에서 설명되지 않았습니다:

        1. 더 이상 사용되지 않음;

        2. 향후 계획된 사용을 위해 예약됨;

        3. 현재 사용 중이지만 현재 IRC 서버의 비일반적인 '기능'의
           일부임.

        209     RPL_TRACECLASS          217     RPL_STATSQLINE
        231     RPL_SERVICEINFO         232     RPL_ENDOFSERVICES
        233     RPL_SERVICE             234     RPL_SERVLIST
        235     RPL_SERVLISTEND
        316     RPL_WHOISCHANOP         361     RPL_KILLDONE
        362     RPL_CLOSING             363     RPL_CLOSEEND
        373     RPL_INFOSTART           384     RPL_MYPORTIS
        466     ERR_YOUWILLBEBANNED     476     ERR_BADCHANMASK
        492     ERR_NOSERVICEHOST

### 7. 클라이언트와 서버 인증

클라이언트와 서버는 모두 동일한 수준의 인증을 받습니다. 둘 다, 서버에 대한 모든 연결에 대해 IP 번호에서 호스트 이름으로의 조회(및 이에 대한 역방향 확인)가 수행됩니다. 그런 다음 두 연결 모두 비밀번호 확인을 받습니다(해당 연결에 대해 비밀번호가 설정된 경우). 이러한 확인은 모든 연결에서 가능하지만 비밀번호 확인은 일반적으로 서버에서만 사용됩니다.

점점 더 일반화되고 있는 추가 확인은 연결을 만드는 책임이 있는 사용자 이름을 찾는 것입니다. 연결의 다른 끝에 있는 사용자 이름을 찾는 것은 일반적으로 RFC 1413에 설명된 것처럼 IDENT와 같은 인증 서버에 연결하는 것을 포함합니다.

비밀번호 없이는 네트워크 연결의 다른 쪽 끝에 누가 있는지 신뢰할 수 있게 결정하는 것이 쉽지 않다는 점을 감안할 때, ident 서버와 같은 다른 조치와 함께 서버 간 연결에서 비밀번호 사용이 강력히 권장됩니다.

### 8. 현재 구현

이 프로토콜의 현재 유일한 구현은 IRC 서버 버전 2.8입니다. 이전 버전은 이 문서에서 설명하는 명령의 일부 또는 전부를 구현할 수 있으며, 많은 숫자 응답을 NOTICE 메시지로 대체합니다. 불행히도 하위 호환성 요구사항으로 인해 이 문서의 일부 구현이 명시된 것과 다릅니다. 주목할 만한 차이점은 다음과 같습니다:

        * 메시지의 어디에든 있는 LF나 CR이 해당 메시지의 끝을 표시한다는
          인식(CR-LF를 요구하는 대신);

이 섹션의 나머지 부분은 주로 서버를 구현하고자 하는 사람들에게 중요한 문제를 다루지만 일부는 클라이언트에도 직접 적용됩니다.

#### 8.1 네트워크 프로토콜: TCP - 여기서 왜 가장 잘 사용되는가

IRC는 TCP가 이 규모의 회의에 잘 맞는 신뢰할 수 있는 네트워크 프로토콜을 제공하기 때문에 TCP 위에서 구현되었습니다. 멀티캐스트 IP의 사용은 대안이지만, 현재는 널리 사용할 수 없거나 지원되지 않습니다.

##### 8.1.1 Unix 소켓 지원

Unix 도메인 소켓이 listen/connect 작업을 허용한다는 점을 고려하여, 현재 구현은 Unix 도메인 소켓에서 클라이언트와 서버 연결을 모두 수신하고 수락하도록 구성할 수 있습니다. 이들은 호스트 이름이 '/'로 시작하는 소켓으로 인식됩니다.

Unix 도메인 소켓의 연결에 대한 정보를 제공할 때, 실제 소켓 이름이 요청되지 않는 한 서버는 경로 이름 대신 실제 호스트 이름을 제공해야 합니다.

#### 8.2 명령 파싱

클라이언트와 서버에 유용한 '비버퍼링' 네트워크 IO를 제공하기 위해, 각 연결에는 가장 최근의 읽기와 파싱 결과가 유지되는 자체 개인 '입력 버퍼'가 제공됩니다. 완전한 메시지 1개를 보관하기 위해 512바이트의 버퍼 크기가 사용되지만, 이는 보통 여러 명령을 보관할 수 있습니다. 개인 버퍼는 모든 읽기 작업 후에 유효한 메시지를 찾기 위해 파싱됩니다. 버퍼에서 한 클라이언트의 여러 메시지를 처리할 때, 하나가 클라이언트를 '제거'하게 되는 경우에 주의해야 합니다.

#### 8.3 메시지 전달

네트워크 링크가 포화상태가 되거나 데이터를 보내는 호스트가 데이터를 보낼 수 없는 경우를 발견하는 것은 일반적입니다. Unix는 일반적으로 TCP 윈도우와 내부 버퍼를 통해 이를 처리하지만, 서버는 종종 많은 양의 데이터를 보내야 하며(특히 새로운 서버-서버 링크가 형성될 때) 커널에서 제공하는 작은 버퍼는 발신 대기열에 충분하지 않습니다. 이 문제를 완화하기 위해 "발신 대기열"이 보낼 데이터의 FIFO 대기열로 사용됩니다. 전형적인 "발신 대기열"은 새 서버가 연결될 때 느린 네트워크 연결을 가진 큰 IRC 네트워크에서 200 Kbytes까지 성장할 수 있습니다.

연결을 폴링할 때, 서버는 먼저 모든 수신 데이터를 읽고 파싱하여 발신할 모든 데이터를 대기열에 넣습니다. 사용 가능한 모든 입력이 처리되면, 대기열에 있는 데이터가 전송됩니다. 이는 write() 시스템 호출의 수를 줄이고 TCP가 더 큰 패킷을 만들 수 있도록 돕습니다.

#### 8.4 연결 '활성도'

연결이 끊어졌거나 응답하지 않게 되었는지 감지하기 위해, 서버는 주어진 시간 내에 응답을 받지 못하는 모든 연결에 ping을 보내야 합니다.

연결이 제시간에 응답하지 않으면, 적절한 절차를 사용하여 연결이 종료됩니다. 연결의 sendq가 허용된 최대치를 초과하면 연결도 끊어집니다. 서버 프로세스가 블록되는 것보다는 느린 연결을 닫는 것이 더 나기 때문입니다.

#### 8.5 서버-클라이언트 연결 설정

IRC 서버에 연결할 때, 클라이언트는 MOTD(있는 경우)와 현재 사용자/서버 수(LUSER 명령에 따라)를 받습니다. 서버는 또한 클라이언트에게 서버의 이름과 버전을 명확하게 명시하는 메시지와 적절하다고 판단되는 다른 모든 소개 메시지를 제공해야 합니다.

이를 처리한 후, 서버는 새 사용자의 닉네임과 자신이 제공한(USER 명령) 및 서버가 발견할 수 있었던(DNS/인증 서버에서) 다른 정보를 보내야 합니다. 서버는 NICK을 먼저 보낸 다음 USER를 보내야 합니다.

#### 8.6 서버-서버 연결 설정

서버-서버 연결을 설정하는 과정은 문제가 발생할 수 있는 많은 가능한 영역이 있기 때문에 위험이 따릅니다 - 이 중 가장 적은 것이 경쟁 조건입니다.

서버가 유효한 것으로 인식된 PASS/SERVER 쌍이 뒤따르는 연결을 받은 후, 서버는 해당 연결에 대한 자체 PASS/SERVER 정보와 아래에 설명된 대로 알고 있는 다른 모든 상태 정보로 응답해야 합니다.

시작 서버가 PASS/SERVER 쌍을 받으면, 연결을 해당 서버로 수락하기 전에 응답하는 서버도 제대로 인증되었는지 확인합니다.

##### 8.6.1 연결 시 서버 간 상태 정보 교환

서버 간에 교환되는 상태 정보의 순서는 필수적입니다. 필요한 순서는 다음과 같습니다:

        * 알려진 다른 모든 서버;

        * 알려진 모든 사용자 정보;

        * 알려진 모든 채널 정보.

서버에 관한 정보는 추가 SERVER 메시지를 통해 전송되고, 사용자 정보는 NICK/USER/MODE/JOIN 메시지를 통해, 그리고 채널은 MODE 메시지를 통해 전송됩니다.

참고: 채널 주제는 TOPIC 명령이 이전 주제 정보를 덮어쓰기 때문에 여기서 교환되지 *않습니다*. 따라서 최선의 경우에도 연결의 양쪽이 주제를 교환할 것입니다.

먼저 서버에 대한 상태 정보를 전달함으로써, 특정 닉네임을 소개하는 두 번째 서버로 인한 닉네임 충돌이 발생하기 전에 이미 존재하는 서버와의 충돌이 발생합니다. IRC 네트워크는 비순환 그래프로만 존재할 수 있기 때문에, 네트워크가 이미 다른 위치에서 다시 연결되었을 수 있으며, 충돌이 발생하는 위치는 네트워크가 분할되어야 하는 위치를 나타냅니다.

#### 8.7 서버-클라이언트 연결 종료

클라이언트 연결이 종료되면, 클라이언트가 연결된 서버에 의해 클라이언트를 대신하여 QUIT 메시지가 생성됩니다. 다른 메시지는 생성되거나 사용되어서는 안 됩니다.

#### 8.8 서버-서버 연결 종료

서버-서버 연결이 원격에서 생성된 SQUIT나 '자연적인' 원인으로 인해 종료되면, 연결된 IRC 네트워크의 나머지 부분은 종료를 감지한 서버에 의해 정보가 업데이트되어야 합니다. 그러면 서버는 SQUIT 목록(해당 연결 뒤에 있는 각 서버에 대해 하나씩)과 QUIT 목록(다시, 해당 연결 뒤에 있는 각 클라이언트에 대해 하나씩)을 보냅니다.

#### 8.9 닉네임 변경 추적

모든 IRC 서버는 최근 닉네임 변경 기록을 유지해야 합니다. 이는 닉네임-변경 경쟁 조건이 발생할 때 그것들을 조작하는 명령과 함께 서버가 상황을 따라잡을 기회를 가질 수 있도록 하기 위해 필요합니다. 닉네임 변경을 추적해야 하는 명령은 다음과 같습니다:

        * KILL (죽임을 당하는 닉)

        * MODE (+/- o,v)

        * KICK (킥을 당하는 닉)

다른 명령들은 닉네임 변경을 확인할 필요가 없습니다.

위의 경우에서, 서버는 먼저 닉네임의 존재를 확인한 다음 그 닉이 현재 누구에게 속하는지(있다면!) 보기 위해 기록을 확인해야 합니다. 이는 경쟁 조건의 가능성을 줄이지만 서버가 잘못된 클라이언트에 영향을 미치는 상황이 여전히 발생할 수 있습니다. 위의 명령에 대한 변경 추적을 수행할 때는 시간 범위를 주고 너무 오래된 항목은 무시하는 것이 권장됩니다.

합리적인 기록을 위해, 서버는 알고 있는 모든 클라이언트가 모두 변경하기로 결정한 경우 각 클라이언트에 대한 이전 닉네임을 유지할 수 있어야 합니다. 이 크기는 다른 요인(메모리 등)에 의해 제한됩니다.

#### 8.10 클라이언트 플러드 제어

상호 연결된 IRC 서버의 큰 네트워크에서, 네트워크에 연결된 단일 클라이언트가 네트워크를 플러딩할 뿐만 아니라 다른 사람들에게 제공되는 서비스 수준을 저하시키는 연속적인 메시지 스트림을 제공하는 것은 매우 쉽습니다. 모든 '피해자'가 자신의 보호를 제공하도록 요구하는 대신, 플러드 보호가 서버에 내장되어 있고 서비스를 제외한 모든 클라이언트에 적용됩니다. 현재 알고리즘은 다음과 같습니다:

        * 클라이언트의 '메시지 타이머'가 현재 시간보다 작은지 확인
          (같다면 같게 설정);

        * 클라이언트로부터 존재하는 데이터 읽기;

        * 타이머가 현재 시간보다 10초 앞서있는 동안, 존재하는 모든
          메시지를 파싱하고 각 메시지에 대해 클라이언트에 2초
          페널티 부과;

이는 본질적으로 클라이언트가 부정적인 영향을 받지 않고 2초마다 1개의 메시지를 보낼 수 있다는 것을 의미합니다.

#### 8.11 비차단 조회

실시간 환경에서는 서버 프로세스가 모든 클라이언트를 공정하게 서비스할 수 있도록 가능한 한 대기를 적게 하는 것이 필수적입니다. 이는 명백히 모든 네트워크 읽기/쓰기 작업에 대해 비차단 IO가 필요합니다. 일반적인 서버 연결의 경우 이는 어렵지 않았지만, 서버가 차단될 수 있는 다른 지원 작업(예: 디스크 읽기)이 있습니다. 가능한 경우, 이러한 활동은 짧은 타임아웃으로 수행되어야 합니다.

##### 8.11.1 호스트네임(DNS) 조회

Berkeley 및 다른 곳의 표준 리졸버 라이브러리를 사용하면 응답이 타임아웃된 일부 경우에 큰 지연이 발생했습니다. 이를 피하기 위해, 비차단 IO 작업을 위해 설정되고 주 서버 IO 루프 내에서 폴링되는 별도의 DNS 루틴 세트가 작성되었습니다.

##### 8.11.2 사용자이름(Ident) 조회

다른 프로그램에 사용하고 포함시킬 수 있는 많은 ident 라이브러리가 있지만, 이들은 동기식으로 작동하고 빈번한 지연을 초래했기 때문에 문제가 되었습니다. 다시 한 번 해결책은 서버의 나머지 부분과 협력하고 비차단 IO를 사용하여 작동하는 루틴 세트를 작성하는 것이었습니다.

#### 8.12 설정 파일

서버를 유연하게 설정하고 실행하는 방법을 제공하기 위해, 다음에 대한 서버 지침을 포함하는 설정 파일을 사용하는 것이 권장됩니다:

        * 클라이언트 연결을 수락할 호스트;

        * 서버로 연결할 수 있는 호스트;

        * 연결할 호스트(능동적 및 수동적 모두);

        * 서버가 있는 위치에 대한 정보(대학, 도시/주,
          회사가 이에 대한 예시);

        * 서버를 책임지는 사람과 연락할 수 있는 이메일 주소;

        * 제한된 운영자 명령에 접근하고자 하는 클라이언트의
          호스트네임과 비밀번호.

호스트네임을 지정할 때, 도메인 이름과 '점' 표기법(127.0.0.1) 사용 모두를 수락해야 합니다. 모든 발신 및 수신 연결에 사용/수락될 비밀번호를 지정할 수 있어야 합니다(단, 유일한 발신 연결은 다른 서버에 대한 것임).

위 목록은 다른 서버와 연결하고자 하는 모든 서버의 최소 요구사항입니다. 유용할 수 있는 다른 항목들은 다음과 같습니다:

        * 다른 서버가 소개할 수 있는 서버 지정;

        * 서버 분기가 얼마나 깊어질 수 있는지;

        * 클라이언트가 연결할 수 있는 시간.

#### 8.12.1 클라이언트 연결 허용

서버는 시작 시 읽는 일종의 '접근 제어 목록'(설정 파일이나 다른 곳에)을 사용하여 어떤 호스트가 클라이언트를 사용하여 연결할 수 있는지 결정해야 합니다.

호스트 접근 제어에 필요한 유연성을 제공하기 위해 'deny'와 'allow' 모두 구현되어야 합니다.

#### 8.12.2 운영자

파괴적인 사람에게 운영자 권한을 부여하는 것은 그들에게 주어진 권한으로 인해 일반적으로 IRC 네트워크의 안녕에 심각한 결과를 초래할 수 있습니다. 따라서 이러한 권한의 획득은 매우 쉽지 않아야 합니다. 현재 설정은 두 개의 '비밀번호'를 사용해야 하지만 그 중 하나는 보통 쉽게 추측할 수 있습니다. 운영자 비밀번호를 설정 파일에 저장하는 것은 하드 코딩하는 것보다 선호되며 쉬운 도난을 방지하기 위해 암호화된 형식(즉, Unix의 crypt(3) 사용)으로 저장되어야 합니다.

#### 8.12.3 서버 연결 허용

서버의 상호 연결은 사소한 문제가 아닙니다: 잘못된 연결은 IRC의 유용성에 큰 영향을 미칠 수 있습니다. 따라서 각 서버는 연결할 수 있는 서버와 연결할 수 있는 서버의 목록이 있어야 합니다. 어떤 상황에서도 서버가 임의의 호스트가 서버로 연결하는 것을 허용해서는 안 됩니다. 어떤 서버가 연결할 수 있고 없는지 외에도, 설정 파일은 해당 링크의 비밀번호와 다른 특성도 저장해야 합니다.

#### 8.12.4 관리

ADMIN 명령에 대한 정확하고 유효한 응답을 제공하기 위해(4.3.7절 참조), 서버는 설정에서 관련 세부 정보를 찾아야 합니다.

#### 8.13 채널 멤버십

현재 서버는 모든 등록된 로컬 사용자가 최대 10개의 다른 채널에 가입할 수 있도록 합니다. 비로컬 사용자에게는 제한이 부과되지 않아 서버가 채널 멤버십 기준에서 다른 모든 서버와 (합리적으로) 일관성을 유지합니다.
